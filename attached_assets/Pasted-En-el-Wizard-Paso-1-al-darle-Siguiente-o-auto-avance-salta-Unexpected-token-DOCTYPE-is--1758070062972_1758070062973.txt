En el Wizard Paso 1, al darle Siguiente (o auto-avance) salta: Unexpected token '<', '<!DOCTYPE' is not valid JSON.
Necesito que TODAS las APIs del wizard respondan application/json (también en error) y que el front llame a las rutas correctas con el prefijo del blueprint.

1) Rutas backend (verificá y corregí prefijos)

El blueprint de obras usa url_prefix='/obras'. Confirmá que existan exactamente estas rutas:

GET /obras/api/wizard-tareas/etapas?obra_id=:id

POST /obras/api/obras/:obra_id/etapas/bulk_from_catalog (idempotente)

POST /obras/api/wizard-tareas/preview

GET /obras/api/obras/:obra_id/equipo (si la usa Paso 3)

Si preview está en otro path (p. ej. sin /api o sin /obras), moverlo a /obras/api/wizard-tareas/preview.

2) Todas las APIs deben devolver JSON (también en error)

En cada view, envolvé en try/except y usá jsonify:

from flask import jsonify, request, current_app

@obras_bp.post("/api/wizard-tareas/preview")
def wizard_preview():
    try:
        data = request.get_json(force=True)
        obra_id = int(data["obra_id"])
        etapa_ids = list(map(int, data["etapa_ids"]))
        # ... armar preview ...
        return jsonify({"ok": True, "preview": preview_data}), 200
    except Exception as e:
        current_app.logger.exception("wizard_preview")
        return jsonify({"ok": False, "error": str(e)}), 400


Importante: No render_template ni redirects en estas rutas.

Opcional (muy útil): devolver JSON en 401/404 para paths /obras/api/:

@obras_bp.app_errorhandler(401)
def _unauth(e):
    if request.path.startswith("/obras/api/"):
        return jsonify({"ok": False, "error": "Unauthorized"}), 401
    return e

@obras_bp.app_errorhandler(404)
def _notfound(e):
    if request.path.startswith("/obras/api/"):
        return jsonify({"ok": False, "error": "Not found"}), 404
    return e

3) Frontend — usar SIEMPRE fetchJSON y el prefijo correcto

En templates/obras/detalle.html (JS del wizard):

const PREF = '/obras'; // prefijo real

async function fetchJSON(url, opts){
  const r = await fetch(url, opts);
  const txt = await r.text();
  const ct  = r.headers.get('content-type') || '';
  if(!r.ok) throw new Error(`HTTP ${r.status}: ${txt.slice(0,300)}`);
  if(!ct.includes('application/json')) throw new Error(`No JSON (${ct}): ${txt.slice(0,300)}`);
  return JSON.parse(txt);
}

// En Paso 1, cuando avanzamos:
async function callPreview(etapaIds){
  const body = { obra_id: window.obraId, etapa_ids: etapaIds };
  console.log('POST preview ->', `${PREF}/api/wizard-tareas/preview`, body);
  return fetchJSON(`${PREF}/api/wizard-tareas/preview`, {
    method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify(body)
  });
}


Revisá que todas las llamadas usen PREF (bulk, preview, etapas, equipo).
Si hay alguna con /api/... sin PREF, corregir.

4) Navegación del wizard (fix al gotoPaso)

Agregar un adapter para que gotoPaso(2) funcione en este wizard:

(function(){
  if (typeof window.gotoPaso !== 'function') {
    if (window.wizardTareas?.goToStep) {
      window.gotoPaso = step => window.wizardTareas.goToStep(step);
    } else if (typeof window.goToStep === 'function') {
      window.gotoPaso = window.goToStep;
    } else if (typeof window.nextStep === 'function') {
      window.gotoPaso = function(step){ window.nextStep(); };
    } else {
      window.gotoPaso = function(){};
      console.warn('No navigation fn found for wizard');
    }
  }
})();

5) Delegación de eventos y mensajes

El contenedor del grid del catálogo debe tener id="wizardPaso1Container".

El modal: id="wizardModal" (o actualizar el JS al id real que tenga).

Quitar/ocultar el mensaje legacy “Primero debes agregar…” (agregarle clase wizard-legacy-note y removerlo por JS).

Asegurar el contenedor de error #wizardPaso1Warning y escribir ahí los errores reales.

6) QA que deben correr ellos (Network)

Click en Siguiente en Paso 1 (o al tildar) → revisar en Network la request que falla.
Debe ir a /obras/api/wizard-tareas/preview y responder application/json.

Si ven text/html o un redirect → ajustar ruta/prefijo o handler de error como arriba.

7) Criterios de aceptación

Tildar 1–2 etapas → se crean/recuperan y pasa solo a Paso 2.

Siguiente hace lo mismo (bulk + preview + avanzar).

Nunca más <!DOCTYPE ...>; si falla, se ve {"ok":false,"error":"<mensaje>"} y en el UI: Error: <mensaje>.