Bug crítico: no cargan las tareas de la etapa (500 + JSON parse)

Síntoma

Al desplegar la etapa “Revoque Fino” se dispara:

GET /obras/etapas/125/tareas → 500 Internal Server Error

En consola: SyntaxError: Unexpected token '<', "<!doctype"... is not valid JSON

Causa probable

El frontend está haciendo response.json() para esta request, pero el endpoint devuelve HTML (o un HTML de error por el 500). Resultado: intenta parsear HTML como JSON y explota.

Además, hay una excepción del lado servidor en /obras/etapas/<int:etapa_id>/tareas.

✅ Qué arreglar (paso a paso)
1) Backend – endpoint consistente y robusto

Ruta: @obras_bp.get('/etapas/<int:etapa_id>/tareas')

Hacer que DEVUELVA HTML (fragmento) y nunca JSON para esta ruta.

@obras_bp.get("/etapas/<int:etapa_id>/tareas")
@login_required
def api_listar_tareas(etapa_id):
    try:
        etapa = Etapa.query.get_or_404(etapa_id)

        # RBAC: admin/pm ven todo; operario solo sus tareas asignadas
        if current_user.role in ("admin", "pm"):
            tareas = Tarea.query.filter_by(etapa_id=etapa.id).order_by(Tarea.id.desc()).all()
        else:
            tareas = (
                db.session.query(Tarea)
                .join(TareaMiembro, TareaMiembro.tarea_id == Tarea.id)
                .filter(Tarea.etapa_id == etapa.id, TareaMiembro.user_id == current_user.id)
                .order_by(Tarea.id.desc())
                .all()
            )

        # Render de fragmento
        return render_template("obras/_tareas_lista.html", tareas=tareas, etapa=etapa), 200

    except Exception as e:
        current_app.logger.exception("Error cargando tareas de etapa %s", etapa_id)
        return render_template("errors/fragment_500.html", mensaje=str(e)), 500


Notas

Usar el ID real de la etapa (el que viene en la URL), no el número de “pastilla”.

Si hay excepción, renderizar un fragmento HTML que muestre “Error al cargar tareas”, no devolver JSON.

Mantener el filtro por rol: admin/pm todo, operario solo las suyas (join con TareaMiembro).

2) Frontend – leer texto/HTML, nunca JSON

En templates/obras/detalle.html (o el JS ligado), asegurar que para esta ruta se usa response.text():

async function loadTareas(etapaId) {
  const r = await fetch(`/obras/etapas/${etapaId}/tareas`);
  if (!r.ok) {
    document.querySelector(`#tareas-${etapaId}`).innerHTML =
      `<div class="text-danger small">Error al cargar tareas</div>`;
    return;
  }
  const html = await r.text();             // <-- NO json()
  document.querySelector(`#tareas-${etapaId}`).innerHTML = html;
}


Asegurarse también de:

El contenedor existe: id="tareas-{{ etapa.id }}".

El botón/accordion de la etapa tiene data-etapa-id="{{ etapa.id }}" y se pasa ese ID de DB a loadTareas.

3) Verificación rápida

DevTools → Red (Fetch/XHR).

Desplegar “Revoque Fino”.

Ver que GET /obras/etapas/<ID>/tareas:

200 OK

Response es HTML (empieza con <div...), sin <!doctype 500….

La UI muestra la lista de tareas.

Operario (ej. momi giardina) ve solo sus tareas asignadas.

Admin/PM ven todas.

4) (Opcional) Curl de sanity check
curl -i https://<HOST>/obras/etapas/125/tareas
# Esperado: 200 y <div ... en el cuerpo