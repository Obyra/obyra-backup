diff --git a/obras.py b/obras.py
index 77f1fe59dad9c0394b5eeab5124e330d8526da24..32a794954c01598b12fa61a1e413cfea50afe94a 100644
--- a/obras.py
+++ b/obras.py
@@ -1,32 +1,32 @@
 from flask import Blueprint, render_template, request, flash, redirect, url_for, jsonify, current_app
 from flask_login import login_required, current_user
 from datetime import datetime, date
 from decimal import Decimal, ROUND_HALF_UP
 import requests
 from app import db
-from sqlalchemy import text
+from sqlalchemy import text, func
 from sqlalchemy.exc import ProgrammingError
 from models import Obra, EtapaObra, TareaEtapa, AsignacionObra, Usuario, CertificacionAvance, TareaResponsables, ObraMiembro, TareaMiembro, TareaAvance, TareaAdjunto, TareaAvanceFoto
 from etapas_predefinidas import obtener_etapas_disponibles, crear_etapas_para_obra
 from tareas_predefinidas import TAREAS_POR_ETAPA
 from geocoding import geocodificar_direccion, normalizar_direccion_argentina
 from roles_construccion import obtener_roles_por_categoria, obtener_nombre_rol
 
 obras_bp = Blueprint('obras', __name__)
 
 # Error handlers for AJAX requests to return JSON instead of HTML
 @obras_bp.errorhandler(404)
 def handle_404(error):
     # Always return JSON for API routes
     if request.path.startswith("/obras/api/"):
         return jsonify({"ok": False, "error": "Not found"}), 404
     # Check if this is an AJAX request (common indicators)
     if request.is_json or 'application/json' in request.headers.get('Accept', ''):
         return jsonify({'ok': False, 'error': 'Recurso no encontrado'}), 404
     # For regular web requests, let Flask handle it normally
     raise error
 
 @obras_bp.errorhandler(500)  
 def handle_500(error):
     # Always return JSON for API routes
     if request.path.startswith("/obras/api/"):
diff --git a/obras.py b/obras.py
index 77f1fe59dad9c0394b5eeab5124e330d8526da24..32a794954c01598b12fa61a1e413cfea50afe94a 100644
--- a/obras.py
+++ b/obras.py
@@ -2769,102 +2769,118 @@ def create_obra_etapa(obra_id):
 
 
 # API Endpoints for Wizard as per user specification
 
 @obras_bp.route('/api/wizard-tareas/preview', methods=['POST'])
 @login_required
 def wizard_preview():
     """Step 2 - Preview tasks filtered by selected etapas"""
     try:
         data = request.get_json()
         etapa_ids = data.get("etapa_ids", [])
         obra_id = data.get("obra_id")
         
         if not etapa_ids:
             return jsonify({"ok": False, "error": "etapa_ids requeridos"}), 400
             
         if not obra_id:
             return jsonify({"ok": False, "error": "obra_id requerido"}), 400
             
         # Verificar permisos
         obra = Obra.query.get_or_404(obra_id)
         if not can_manage_obra(obra):
             return jsonify({"ok": False, "error": "Sin permisos"}), 403
         
         # üéØ CORRECCI√ìN: etapa_ids son IDs del CAT√ÅLOGO, no de etapas existentes
-        from etapas_predefinidas import ETAPAS_CONSTRUCCION
-        from tareas_predefinidas import TAREAS_POR_ETAPA
-        
-        current_app.logger.debug(f"üî• DEBUG WIZARD: Recibidos etapa_ids del cat√°logo: {etapa_ids}")
-        current_app.logger.debug(f"üî• DEBUG WIZARD: Total etapas en cat√°logo: {len(ETAPAS_CONSTRUCCION)}")
-        
+        catalogo = obtener_etapas_disponibles()
+        catalogo_por_id = {str(etapa.get("id")): etapa for etapa in catalogo}
+
+        current_app.logger.debug(
+            "üî• DEBUG WIZARD: Recibidos etapa_ids del cat√°logo: %s", etapa_ids
+        )
+        current_app.logger.debug(
+            "üî• DEBUG WIZARD: Total etapas en cat√°logo: %s", len(catalogo)
+        )
+
         # üéØ Construir respuesta desde el cat√°logo predefinido
         etapas_data = []
-        
+
         for etapa_id in etapa_ids:
-            # Buscar la etapa en el cat√°logo predefinido
-            etapa_def = None
-            for etapa in ETAPAS_CONSTRUCCION:
-                if etapa.get("id") == etapa_id:
-                    etapa_def = etapa
-                    break
-            
+            etapa_def = catalogo_por_id.get(str(etapa_id))
             if not etapa_def:
-                current_app.logger.warning(f"‚ùå DEBUG WIZARD: Etapa con ID {etapa_id} NO encontrada en cat√°logo")
+                current_app.logger.warning(
+                    "‚ùå DEBUG WIZARD: Etapa con ID %s NO encontrada en cat√°logo", etapa_id
+                )
                 continue
-                
+
             etapa_nombre = etapa_def.get("nombre", f"Etapa {etapa_id}")
-            current_app.logger.debug(f"‚úÖ DEBUG WIZARD: Procesando etapa del cat√°logo '{etapa_nombre}' (ID: {etapa_id})")
-            
+            etapa_slug = etapa_def.get("slug")
+            current_app.logger.debug(
+                "‚úÖ DEBUG WIZARD: Procesando etapa del cat√°logo '%s' (ID: %s, slug: %s)",
+                etapa_nombre,
+                etapa_def.get("id"),
+                etapa_slug,
+            )
+
             # Tareas del cat√°logo por tipo de etapa
             tareas_catalogo = []
-            current_app.logger.debug(f"üî• DEBUG WIZARD: Claves disponibles en TAREAS_POR_ETAPA: {list(TAREAS_POR_ETAPA.keys())}")
-            
             if etapa_nombre in TAREAS_POR_ETAPA:
-                current_app.logger.debug(f"‚úÖ DEBUG WIZARD: Encontrada etapa '{etapa_nombre}' en cat√°logo de tareas")
+                current_app.logger.debug(
+                    "‚úÖ DEBUG WIZARD: Encontrada etapa '%s' en cat√°logo de tareas", etapa_nombre
+                )
                 for idx, tarea_def in enumerate(TAREAS_POR_ETAPA[etapa_nombre]):
                     tareas_catalogo.append({
-                        "codigo": f"cat_{etapa_id}_{idx}",
+                        "codigo": f"cat_{etapa_def.get('id')}_{idx}",
                         "nombre": tarea_def.get("nombre", "Tarea sin nombre"),
                         "unidad_default": tarea_def.get("unidad", "h")
                     })
             else:
-                current_app.logger.warning(f"‚ùå DEBUG WIZARD: Etapa '{etapa_nombre}' NO encontrada en TAREAS_POR_ETAPA")
-            
+                current_app.logger.warning(
+                    "‚ùå DEBUG WIZARD: Etapa '%s' NO encontrada en TAREAS_POR_ETAPA",
+                    etapa_nombre,
+                )
+
             # Para el wizard, no incluimos tareas existentes ya que estamos creando nuevas
             tareas_existentes = []
-            
+
             etapas_data.append({
-                "etapa_id": etapa_id,  # ID del cat√°logo
+                "etapa_id": etapa_def.get("id"),  # ID del cat√°logo
+                "etapa_slug": etapa_slug,
                 "etapa_nombre": etapa_nombre,
                 "tareas_catalogo": tareas_catalogo,
                 "tareas_existentes": tareas_existentes
             })
-            
-            current_app.logger.debug(f"üìä DEBUG WIZARD: Etapa {etapa_nombre} - {len(tareas_catalogo)} tareas cat√°logo")
-        
-        current_app.logger.debug(f"üéØ DEBUG WIZARD: Respuesta final con {len(etapas_data)} etapas")
+
+            current_app.logger.debug(
+                "üìä DEBUG WIZARD: Etapa %s - %s tareas cat√°logo",
+                etapa_nombre,
+                len(tareas_catalogo),
+            )
+
+        current_app.logger.debug(
+            "üéØ DEBUG WIZARD: Respuesta final con %s etapas", len(etapas_data)
+        )
         # üéØ Respuesta con esquema exacto seg√∫n especificaci√≥n del usuario
         return jsonify({
             "ok": True,
             "obra_id": obra_id,
             "etapas": etapas_data
         })
         
     except Exception as e:
         current_app.logger.exception("Error en wizard preview")
         return jsonify({"ok": False, "error": f"Error interno: {str(e)}"}), 500
 
 
 @obras_bp.route('/api/obras/<int:obra_id>/equipo', methods=['GET'])
 @login_required
 def get_obra_equipo(obra_id):
     """Get team members for obra (for wizard step 3)"""
     try:
         # Verificar permisos
         obra = Obra.query.get_or_404(obra_id)
         if not can_manage_obra(obra):
             return jsonify({"error": "Sin permisos"}), 403
         
         # Obtener miembros del equipo
         miembros = (ObraMiembro.query
                    .filter_by(obra_id=obra_id)
diff --git a/obras.py b/obras.py
index 77f1fe59dad9c0394b5eeab5124e330d8526da24..32a794954c01598b12fa61a1e413cfea50afe94a 100644
--- a/obras.py
+++ b/obras.py
@@ -2889,132 +2905,245 @@ def get_obra_equipo(obra_id):
 @obras_bp.route('/api/wizard-tareas/create', methods=['POST'])
 @login_required
 def wizard_create():
     """Step 4 - Create tasks in batch with assignments"""
     try:
         data = request.get_json()
         obra_id = data.get("obra_id")
         tareas_in = data.get("tareas", [])
         
         if not obra_id:
             return jsonify({"error": "obra_id requerido"}), 400
             
         if not tareas_in:
             return jsonify({"error": "No hay tareas para crear"}), 400
         
         # Verificar permisos
         obra = Obra.query.get_or_404(obra_id)
         if not can_manage_obra(obra):
             return jsonify({"error": "Sin permisos"}), 403
         
         creadas = []
         duplicados = []
         
         current_app.logger.info(f"üßô‚Äç‚ôÇÔ∏è WIZARD CREATE: Procesando {len(tareas_in)} tareas para obra {obra_id}")
         
+        catalogo_etapas = obtener_etapas_disponibles()
+        slug_to_nombre = {
+            etapa.get('slug'): etapa.get('nombre')
+            for etapa in catalogo_etapas
+            if etapa.get('slug')
+        }
+        id_to_nombre = {
+            str(etapa.get('id')): etapa.get('nombre')
+            for etapa in catalogo_etapas
+            if etapa.get('id') is not None
+        }
+        id_to_slug = {
+            str(etapa.get('id')): etapa.get('slug')
+            for etapa in catalogo_etapas
+            if etapa.get('id') is not None
+        }
+
+        def _safe_number(value):
+            if value in (None, '', 'null'):
+                return None
+            try:
+                return float(value)
+            except (TypeError, ValueError):
+                return None
+
+        def _safe_user_id(value):
+            if value in (None, '', 'null'):
+                return None
+            try:
+                return int(value)
+            except (TypeError, ValueError):
+                return None
+
         # Use proper transaction context
         try:
             for t in tareas_in:
-                etapa_slug = t.get("etapa_slug")
-                nombre = t.get("nombre")
-                
-                if not etapa_slug or not nombre:
+                nombre = (t.get("nombre") or "").strip()
+                etapa_slug = (t.get("etapa_slug") or "").strip() or None
+                etapa_catalogo_id_raw = (
+                    t.get("etapa_id")
+                    or t.get("catalogo_id")
+                    or t.get("catalog_id")
+                )
+                etapa_nombre_payload = (t.get("etapa_nombre") or "").strip() or None
+
+                if not nombre:
+                    current_app.logger.warning(
+                        "‚ö†Ô∏è WIZARD: Tarea sin nombre descartada (payload: %s)", t
+                    )
                     continue
-                    
-                # Mapear etapa_slug a nombre y buscar etapa_id real
-                try:
-                    from etapas_predefinidas import obtener_etapas_disponibles
-                    catalogo_etapas = obtener_etapas_disponibles()
-                    slug_to_nombre = {e['slug']: e['nombre'] for e in catalogo_etapas}
+
+                etapa_catalogo_id = None
+                if etapa_catalogo_id_raw not in (None, ""):
+                    etapa_catalogo_id = str(etapa_catalogo_id_raw)
+                    if not etapa_slug:
+                        etapa_slug = id_to_slug.get(etapa_catalogo_id)
+
+                etapa_nombre = None
+                if etapa_slug:
                     etapa_nombre = slug_to_nombre.get(etapa_slug)
-                    
-                    if not etapa_nombre:
-                        current_app.logger.warning(f"‚ö†Ô∏è WIZARD: Slug '{etapa_slug}' no encontrado en cat√°logo")
-                        continue
-                        
-                    etapa_real = (EtapaObra.query
-                                 .filter(EtapaObra.obra_id == obra_id)
-                                 .filter(EtapaObra.nombre == etapa_nombre)
-                                 .first())
-                except ImportError:
-                    current_app.logger.error("‚ùå WIZARD: No se pudo importar etapas_predefinidas")
+                if not etapa_nombre and etapa_catalogo_id:
+                    etapa_nombre = id_to_nombre.get(etapa_catalogo_id)
+                if not etapa_nombre and etapa_nombre_payload:
+                    etapa_nombre = etapa_nombre_payload
+
+                if not etapa_nombre:
+                    current_app.logger.warning(
+                        "‚ö†Ô∏è WIZARD: No se pudo determinar la etapa para '%s' (slug=%s, id=%s)",
+                        nombre,
+                        etapa_slug,
+                        etapa_catalogo_id_raw,
+                    )
                     continue
-                
+
+                etapa_real = (
+                    EtapaObra.query
+                    .filter(EtapaObra.obra_id == obra_id)
+                    .filter(func.lower(EtapaObra.nombre) == etapa_nombre.lower())
+                    .first()
+                )
+
+                if not etapa_real and etapa_slug:
+                    pattern = f"%{etapa_slug.replace('-', '%')}%"
+                    etapa_real = (
+                        EtapaObra.query
+                        .filter(EtapaObra.obra_id == obra_id)
+                        .filter(EtapaObra.nombre.ilike(pattern))
+                        .first()
+                    )
+
                 if not etapa_real:
-                    # Si no existe la etapa, saltamos esta tarea
-                    current_app.logger.warning(f"‚ö†Ô∏è WIZARD: Etapa '{etapa_slug}' no encontrada en obra {obra_id}")
+                    current_app.logger.warning(
+                        "‚ö†Ô∏è WIZARD: Etapa '%s' (slug=%s, id=%s) no encontrada en obra %s",
+                        etapa_nombre,
+                        etapa_slug,
+                        etapa_catalogo_id_raw,
+                        obra_id,
+                    )
                     continue
-                    
+
+                if not etapa_slug:
+                    etapa_slug = next(
+                        (
+                            etapa.get('slug')
+                            for etapa in catalogo_etapas
+                            if etapa.get('nombre') == etapa_nombre
+                        ),
+                        None,
+                    )
+
+                if not etapa_catalogo_id:
+                    etapa_catalogo_id = next(
+                        (
+                            str(etapa.get('id'))
+                            for etapa in catalogo_etapas
+                            if etapa.get('slug') == etapa_slug
+                        ),
+                        None,
+                    )
+
                 etapa_id = etapa_real.id
-                    
+
                 # Verificar si ya existe (idempotencia)
-                exists = (TareaEtapa.query
-                         .filter_by(etapa_id=etapa_id, nombre=nombre)
-                         .first())
-                
+                exists = (
+                    TareaEtapa.query
+                    .filter_by(etapa_id=etapa_id, nombre=nombre)
+                    .first()
+                )
+
                 if exists:
-                    duplicados.append({"etapa_id": etapa_id, "nombre": nombre})
-                    current_app.logger.info(f"üìã WIZARD: Tarea duplicada '{nombre}' en etapa {etapa_id}")
+                    duplicados.append({
+                        "etapa_id": etapa_id,
+                        "etapa_slug": etapa_slug,
+                        "etapa": etapa_nombre,
+                        "nombre": nombre,
+                    })
+                    current_app.logger.info(
+                        "üìã WIZARD: Tarea duplicada '%s' en etapa %s",
+                        nombre,
+                        etapa_id,
+                    )
                     continue
-                
+
                 # Parsear fechas
                 fecha_inicio = None
                 fecha_fin = None
-                
+
                 if t.get("fecha_inicio"):
                     try:
                         fecha_inicio = datetime.strptime(t["fecha_inicio"], '%Y-%m-%d').date()
                     except ValueError:
                         pass
                         
                 if t.get("fecha_fin"):
                     try:
                         fecha_fin = datetime.strptime(t["fecha_fin"], '%Y-%m-%d').date()
                     except ValueError:
                         pass
-                
+
+                horas_estimadas = _safe_number(t.get("horas"))
+                cantidad_planificada = _safe_number(t.get("cantidad"))
+                asignado_usuario_id = _safe_user_id(t.get("asignado_usuario_id"))
+
                 # Crear tarea
                 tarea = TareaEtapa(
                     etapa_id=etapa_id,
                     nombre=nombre,
                     descripcion=f"Creada via wizard masivo",
                     estado='pendiente',
-                    unidad=t.get("unidad", "h"),
+                    unidad=(t.get("unidad") or "h"),
                     fecha_inicio_plan=fecha_inicio,
                     fecha_fin_plan=fecha_fin,
-                    horas_estimadas=t.get("horas"),
-                    cantidad_planificada=t.get("cantidad"),
-                    responsable_id=t.get("asignado_usuario_id")
+                    horas_estimadas=horas_estimadas,
+                    cantidad_planificada=cantidad_planificada,
+                    responsable_id=asignado_usuario_id,
                 )
-                
+
                 db.session.add(tarea)
                 db.session.flush()  # Para obtener el ID
-                
+
                 # Asignar usuario en tarea_miembros si viene asignado_usuario_id
-                if t.get("asignado_usuario_id"):
+                if asignado_usuario_id:
                     asignacion = TareaMiembro(
                         tarea_id=tarea.id,
-                        usuario_id=t["asignado_usuario_id"]
+                        usuario_id=asignado_usuario_id,
                     )
                     db.session.add(asignacion)
-                
-                creadas.append({"id": tarea.id, "nombre": tarea.nombre})
-                current_app.logger.info(f"‚ú® WIZARD: Tarea creada '{nombre}' ID:{tarea.id}")
+
+                creadas.append({
+                    "id": tarea.id,
+                    "nombre": tarea.nombre,
+                    "etapa_id": etapa_id,
+                    "etapa_slug": etapa_slug,
+                    "etapa": etapa_nombre,
+                })
+                current_app.logger.info(
+                    "‚ú® WIZARD: Tarea creada '%s' ID:%s (etapa=%s)",
+                    nombre,
+                    tarea.id,
+                    etapa_nombre,
+                )
             
             # Confirmar transacci√≥n
             db.session.commit()
             current_app.logger.info(f"üéâ WIZARD CREATE: {len(creadas)} creadas, {len(duplicados)} duplicadas")
             
             return jsonify({
                 "ok": True,
                 "creadas": creadas,
                 "duplicados": duplicados
             })
             
         except Exception as e:
             db.session.rollback()
             current_app.logger.exception("Error en transacci√≥n wizard create")
             raise e
         
     except Exception as e:
         current_app.logger.exception("Error en wizard create")
         return jsonify({"error": f"Error interno: {str(e)}"}), 500
