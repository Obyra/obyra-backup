Bug: El modal “Registrar Avance” siempre muestra (un) aunque la tarea tenga otra unidad (m², ml, etc).

Causa: El modal no está usando la unidad de la tarea al abrirse (queda el fallback "un").

Arreglo (simple y barato):

1) Backend/Template: pasar la unidad y rendimiento en el botón que abre el modal

En todas las vistas donde aparece el botón “+ Avance” (detalle de obra / mis_tareas):

<button class="btn-avance"
        data-tarea-id="{{ t.id }}"
        data-unidad="{{ t.unidad or 'un' }}"
        data-rendimiento="{{ t.rendimiento or '' }}"
        data-bs-toggle="modal"
        data-bs-target="#modalAvance">
  + Avance
</button>

2) Modal: placeholders simples
<label for="cantidad" id="lbl-cantidad">Cantidad ejecutada (un) *</label>
<div class="input-group">
  <input id="cantidad" name="cantidad" type="number" step="0.01" min="0" required>
  <span class="input-group-text" id="chip-unidad">un</span>
</div>

<input type="hidden" id="rendimiento" value="">
<input type="hidden" id="tarea_id" name="tarea_id" value="">

3) JS: al abrir el modal, setear unidad y rendimiento desde data-*
<script>
(() => {
  const lbl  = document.getElementById('lbl-cantidad');
  const chip = document.getElementById('chip-unidad');
  const rInp = document.getElementById('rendimiento');
  const tInp = document.getElementById('tarea_id');

  // abrir modal
  document.querySelectorAll('.btn-avance').forEach(btn => {
    btn.addEventListener('click', () => {
      const u = btn.dataset.unidad || 'un';
      const r = btn.dataset.rendimiento || '';

      lbl.textContent = `Cantidad ejecutada (${u}) *`;
      chip.textContent = u;
      rInp.value = r;
      tInp.value = btn.dataset.tareaId;

      // auto-conversión cantidad↔horas si hay rendimiento
      const qty   = document.getElementById('cantidad');
      const horas = document.getElementById('horas');
      const rr    = parseFloat(r);
      if (!isNaN(rr) && rr > 0) {
        const onHoras = () => { if (horas.value && !qty.value) qty.value = (parseFloat(horas.value)*rr).toFixed(2); };
        const onQty   = () => { if (qty.value && !horas.value) horas.value = (parseFloat(qty.value)/rr).toFixed(2); };
        horas.oninput = onHoras;  // evitar handlers acumulados
        qty.oninput   = onQty;
      } else {
        // sin rendimiento, no autocalculamos
        document.getElementById('horas').oninput = null;
        document.getElementById('cantidad').oninput = null;
      }
    });
  });
})();
</script>

4) Backend: ignorar unidad del cliente (seguridad)

En crear_avance, usar SIEMPRE tarea.unidad:

tarea = TareaEtapa.query.get(tarea_id)
cantidad = request.form.get('cantidad', type=float)
horas    = request.form.get('horas', type=float)
unidad   = tarea.unidad  # server-side

avance = AvanceTarea(tarea_id=tarea.id, user_id=current_user.id,
                     cantidad=cantidad, unidad=unidad, horas=horas, estado='pendiente')
db.session.add(avance); db.session.commit()

5) Verificación rápida

Editar “Construcción de muros exteriores” y fijar unidad = m².

Abrir modal → debe decir “Cantidad ejecutada (m²)” y chip m².

Cambiar la unidad de la tarea a ml → abrir modal → debe mostrar ml.

Si la tarea tiene rendimiento, probar Horas=2 ⇒ autocompleta cantidad.

Criterio de aceptación: el modal refleja SIEMPRE la unidad de la tarea (sin “un” por defecto), tanto en detalle de obra como en mis_tareas, y el backend guarda la unidad del server.