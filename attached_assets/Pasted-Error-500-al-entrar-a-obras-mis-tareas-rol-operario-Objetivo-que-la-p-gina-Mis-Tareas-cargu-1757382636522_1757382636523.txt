Error: 500 al entrar a /obras/mis-tareas (rol operario).

Objetivo: que la página “Mis Tareas” cargue sin errores y liste solo las tareas asignadas al current_user.

Checklist de fixes (en orden):

Ver el stacktrace

Abrí los logs del servidor, entrá como operario a /obras/mis-tareas y pegá el stacktrace que sale.

Asegurar la ruta y el import

En obras.py (blueprint obras_bp), definí/ajustá esta ruta mínima (y asegurate de tener los imports correctos):

from flask import render_template, redirect, url_for, jsonify, request
from flask_login import login_required, current_user
from models import db, TareaEtapa, TareaMiembro, Etapa, Obra  # <- usar los nombres reales

@obras_bp.route("/mis-tareas")
@login_required
def mis_tareas():
    # Consulta segura: tareas asignadas al usuario actual
    q = (
        db.session.query(TareaEtapa)
          .join(TareaMiembro, TareaMiembro.tarea_id == TareaEtapa.id)
          .join(Etapa, Etapa.id == TareaEtapa.etapa_id)
          .join(Obra, Obra.id == Etapa.obra_id)
          .filter(TareaMiembro.user_id == current_user.id)
    )
    tareas = q.all()

    # Endpoint de prueba si se llama con ?raw=1
    if request.args.get("raw"):
        return jsonify([{"id": t.id} for t in tareas])

    return render_template("obras/mis_tareas.html", tareas=tareas)


Confirmá que el blueprint obras_bp esté registrado con prefijo /obras.

Plantilla mínima y a prueba de fallos

En templates/obras/mis_tareas.html dejá una versión simple para descartar fallos de Jinja:

{% extends "base.html" %}
{% block content %}
<div class="container py-3">
  <h3>Mis tareas</h3>
  {% if tareas|length == 0 %}
    <p class="text-muted">No tenés tareas asignadas.</p>
  {% else %}
    <ul class="list-group">
      {% for t in tareas %}
        <li class="list-group-item d-flex justify-content-between align-items-center">
          <div>
            <strong>{{ t.nombre or "Tarea #"%}}{{ t.id }}</strong>
            {% if t.etapa and t.etapa.obra %}
              <small class="text-muted d-block">
                {{ t.etapa.obra.nombre }} • {{ t.etapa.nombre }}
              </small>
            {% endif %}
          </div>
          <a class="btn btn-sm btn-primary" href="{{ url_for('obras.detalle', obra_id=t.etapa.obra_id) }}">Ver obra</a>
        </li>
      {% endfor %}
    </ul>
  {% endif %}
</div>
{% endblock %}


Nota: no usar t.metrics, ni campos que no existan; solo t.id, t.nombre?, t.etapa?.obra?.nombre.

Relaciones en modelos (si faltan)

En models.py asegurá estas relaciones básicas para no romper el template:

class TareaEtapa(db.Model):
    __tablename__ = "tareas_etapa"   # usar el real
    id = db.Column(db.Integer, primary_key=True)
    etapa_id = db.Column(db.Integer, db.ForeignKey("etapas.id"))
    etapa = db.relationship("Etapa", backref="tareas")
    miembros = db.relationship("TareaMiembro", backref="tarea", cascade="all, delete-orphan")

class TareaMiembro(db.Model):
    __tablename__ = "tarea_miembros" # usar el real
    id = db.Column(db.Integer, primary_key=True)
    tarea_id = db.Column(db.Integer, db.ForeignKey("tareas_etapa.id"), index=True, nullable=False)
    user_id = db.Column(db.Integer, db.ForeignKey("usuarios.id"), index=True, nullable=False)

class Etapa(db.Model):
    __tablename__ = "etapas"
    id = db.Column(db.Integer, primary_key=True)
    obra_id = db.Column(db.Integer, db.ForeignKey("obras.id"))
    obra = db.relationship("Obra", backref="etapas")


Ajustá __tablename__ y FK a los nombres reales.

Probar en pasos

Entrar a /obras/mis-tareas?raw=1 → Debe devolver JSON.

Si funciona, entrar a /obras/mis-tareas → Debe renderizar la lista.

Redirecciones

Confirmar que los operarios son redirigidos a /obras/mis-tareas después del login y que el logo apunta ahí, pero que si entran directo a /obras/mis-tareas no explota.

Si todavía falla

Pegá el stacktrace exacto de los logs y revisamos la línea puntual que revienta (import circular, atributo inexistente, etc.).