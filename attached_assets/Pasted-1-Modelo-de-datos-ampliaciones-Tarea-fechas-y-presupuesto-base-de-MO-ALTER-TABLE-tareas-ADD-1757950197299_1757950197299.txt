1) Modelo de datos (ampliaciones)
-- Tarea: fechas y presupuesto base de MO
ALTER TABLE tareas
  ADD COLUMN IF NOT EXISTS fecha_inicio DATE,
  ADD COLUMN IF NOT EXISTS fecha_fin DATE,
  ADD COLUMN IF NOT EXISTS presupuesto_mo NUMERIC;  -- presupuesto de mano de obra p/ EV/PV

-- Planificación (distribución planificada por semana)
CREATE TABLE IF NOT EXISTS tarea_plan_semanal (
  id SERIAL PRIMARY KEY,
  tarea_id INT NOT NULL REFERENCES tareas(id) ON DELETE CASCADE,
  semana DATE NOT NULL,                -- lunes de la semana (ISO)
  qty_plan NUMERIC DEFAULT 0,          -- cantidad planificada para esa semana (en unidad de la tarea)
  pv_mo NUMERIC DEFAULT 0,             -- PV de mano de obra ($) esa semana (opcional)
  UNIQUE(tarea_id, semana)
);

-- Avance semanal agregado (vista o tabla materializada opcional)
-- (si querés mantenerlo en tabla:)
CREATE TABLE IF NOT EXISTS tarea_avance_semanal (
  id SERIAL PRIMARY KEY,
  tarea_id INT NOT NULL REFERENCES tareas(id) ON DELETE CASCADE,
  semana DATE NOT NULL,
  qty_real NUMERIC DEFAULT 0,          -- cantidad ejecutada aprobada esa semana
  ac_mo NUMERIC DEFAULT 0,             -- costo real MO esa semana (Σ horas * tarifa)
  ev_mo NUMERIC DEFAULT 0,             -- EV ($) esa semana (calculado)
  UNIQUE(tarea_id, semana)
);
CREATE INDEX IF NOT EXISTS idx_tas_tarea_sem ON tarea_avance_semanal(tarea_id, semana);


Nota: si preferís no tener tarea_avance_semanal, podés calcularlo en query (sumando avances aprobados por semana). Guardarlo acelera dashboards.

2) Reglas de planificación (curva S)
2.1 Fechas

Obligatorio definir fecha_inicio y fecha_fin en la tarea.

Validar fecha_fin >= fecha_inicio.

2.2 Distribución planificada

Por defecto, distribución lineal de cantidad_objetivo entre semanas del rango [inicio, fin].

Opción (más preciso): permitir pesos por semana (p.ej., 10%, 15%, 20%…).

Llenar/actualizar tarea_plan_semanal al guardar/editar la tarea.

Algoritmo lineal (resumen):

Listar lunes ISO entre fecha_inicio y fecha_fin.

qty_plan_semana = cantidad_objetivo / n_semanas.

pv_mo_semana = presupuesto_mo / n_semanas (si se cargó presupuesto).

3) Cálculo semanal PV / EV / AC

AC (Actual Cost): Σ( horas_trabajadas_aprobadas * tarifa_hora ) por semana.

EV (Earned Value):

Opción A (por cantidad): EV_qty_sem = (qty_real_acum / qty_plan_total) * presupuesto_mo.

Opción B (semanal): EV_sem = min(qty_real_sem, qty_plan_sem_acum_restante) * (presupuesto_mo / qty_plan_total).

Recomendación: usar A para curva acumulada (más estable).

PV (Planned Value): Σ pv_mo planificado hasta la semana (o proporcional: (qty_plan_acum / qty_plan_total) * presupuesto_mo).

CPI = EV / AC (alerta si < 0.9).

SPI = EV / PV (alerta si < 0.9).

Todos los indicadores se calculan acumulados por semana para graficar curva S (PV, EV, AC).

4) Jobs y alertas
4.1 Job diario (cron)

Todos los días 02:00:

Recalcular resúmenes semanales por tarea (si no materializás).

Calcular PV/EV/AC acumulados por etapa y obra.

Generar alertas cuando:

CPI < 0.9 en tarea o etapa (ej. Mampostería).

SPI < 0.9 (atraso de cronograma).

fecha_hoy > fecha_fin y % tarea < 100% (vencida).

Enviar notificación (email/WhatsApp interno) a Admin: listado con semáforos.

# pseudo
def cron_recalculo():
    for tarea in tareas_activas():
        recomputar_semana(tarea.id)   # agrupa avances aprobados por semana, calcula AC, EV
    generar_alertas()
    enviar_resumen_alertas()

5) Endpoints / Servicios

POST /api/tareas/<id>/plan
Crea/actualiza distribución semanal (lineal por defecto; admite pesos).

GET /api/tareas/<id>/curva-s?desde=YYYY-MM-DD&hasta=YYYY-MM-DD
Devuelve series acumuladas por semana: PV, EV, AC y CPI/SPI.

GET /api/obras/<id>/curva-s y GET /api/etapas/<id>/curva-s
Agregan por ponderación (suma de presupuestos).

GET /api/alertas?scope=obra|etapa|tarea&estado=abierta|cerrada

POST /api/alertas/<id>/cerrar

6) UI (mínimo usable)
6.1 Tarea (Admin)

Campos nuevos: Inicio (date), Fin (date), Cantidad objetivo, Unidad, Presupuesto MO.

Botón “Generar plan semanal” (lineal).
Modal opcional para editar pesos por semana.

Sección “Curva S (MO)”: gráfico líneas PV/EV/AC (acumulado semanal).

KPIs: CPI, SPI, % ejecutado, HH reales, Costo real.

6.2 Etapa / Obra (Admin)

Panel Curva S agregada (PV/EV/AC) + CPI/SPI.

Alertas listadas con filtros (área, severidad, semana).

6.3 Operario (sin cambios de calendario)

Mantiene carga de avances; no toca planificación.

7) Aceptación (QA)

Al definir inicio/fin y cantidad_objetivo/presupuesto_mo en una tarea y guardar:

Se crea tarea_plan_semanal (lineal).

El endpoint de Curva S retorna series acumuladas coherentes (PV creciente lineal, EV/AC según avances).

Al aprobar avances en una semana:

Se actualiza AC y EV de esa semana y acumulados.

CPI y SPI cambian con la semana actual.

Alerta: si CPI < 0.9 en Mampostería, aparece alerta abierta y llega notificación al Admin.

Gráfico muestra 3 líneas (PV, EV, AC) por semana con eje temporal (lunes ISO).

8) Snippets clave

Generar semanas ISO entre inicio/fin

from datetime import date, timedelta

def lunes_iso(d: date) -> date:
    return d - timedelta(days=(d.weekday()))  # 0=lunes

def semanas_entre(inicio: date, fin: date):
    s = lunes_iso(inicio)
    e = lunes_iso(fin)
    weeks = []
    while s <= e:
        weeks.append(s)
        s += timedelta(days=7)
    return weeks


Plan lineal

def generar_plan_lineal(tarea):
    weeks = semanas_entre(tarea.fecha_inicio, tarea.fecha_fin)
    n = max(len(weeks), 1)
    q = float(tarea.cantidad_objetivo or 0) / n
    pv = float(tarea.presupuesto_mo or 0) / n
    upserts = []
    for w in weeks:
        upserts.append(dict(tarea_id=tarea.id, semana=w, qty_plan=q, pv_mo=pv))
    bulk_upsert_tarea_plan_semanal(upserts)  # implementa ON CONFLICT DO UPDATE


Aggregate semanal de avances aprobados

from sqlalchemy import func, cast, DATE

def resumen_real_semanal(tarea_id):
    # semana = lunes ISO
    rows = (db.session.query(
                (func.date_trunc('week', TareaAvance.approved_at)).label('semana'),
                func.sum(TareaAvance.cantidad_ingresada).label('qty_real'),
                func.sum(TareaAvance.horas_trabajadas * Tarifa.hora).label('ac_mo')  # ajustá join/columna
            )
            .join(Tarea, Tarea.id==TareaAvance.tarea_id)
            .outerjoin(Tarifa, Tarifa.operario_id==TareaAvance.operario_id) # si aplica
            .filter(TareaAvance.tarea_id==tarea_id, TareaAvance.estado=='aprobado')
            .group_by('semana')
            .all())
    return rows


Cálculo de curva acumulada

def curva_s_tarea(tarea_id):
    tarea = Tarea.query.get(tarea_id)
    plan = {r.semana: r for r in TareaPlanSemanal.query.filter_by(tarea_id=tarea_id).all()}
    real = {r.semana: r for r in TareaAvanceSemanal.query.filter_by(tarea_id=tarea_id).all()}  # o usar resumen_real_semanal

    weeks = sorted(set(plan.keys()) | set(real.keys()))
    qty_plan_total = sum((plan[w].qty_plan if w in plan else 0) for w in weeks) or 1
    presup = float(tarea.presupuesto_mo or 0)

    pv_acum = ev_acum = ac_acum = qty_real_acum = qty_plan_acum = 0
    out = []
    for w in weeks:
        qty_plan = (plan[w].qty_plan if w in plan else 0)
        pv = (plan[w].pv_mo if w in plan else (presup * qty_plan / qty_plan_total))
        pv_acum += pv
        qty_plan_acum += qty_plan

        qty_real = (real[w].qty_real if w in real else 0)
        ac = (real[w].ac_mo if w in real else 0)
        qty_real_acum += qty_real
        ev_acum = presup * (qty_real_acum / qty_plan_total)
        ac_acum += ac

        cpi = (ev_acum / ac_acum) if ac_acum > 0 else None
        spi = (ev_acum / pv_acum) if pv_acum > 0 else None

        out.append(dict(semana=w.isoformat(), pv=pv_acum, ev=ev_acum, ac=ac_acum, cpi=cpi, spi=spi))
    return out
