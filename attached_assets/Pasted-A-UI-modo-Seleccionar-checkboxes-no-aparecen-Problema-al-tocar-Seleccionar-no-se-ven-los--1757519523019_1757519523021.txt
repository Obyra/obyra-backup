A) UI – modo “Seleccionar” (checkboxes no aparecen)

Problema: al tocar “Seleccionar” no se ven los checkboxes; sólo aparecen cuando cancelás.
Pedido:

Corregir el toggle del modo selección para que agregue la clase al container correcto y muestre los checkboxes de cada tarjeta.

Actualizar el contador de selección en los botones (“Eliminar seleccionadas (N)”, “Asignar usuarios (N)”).

No romper el click en la tarjeta (que no navegue si el checkbox fue clickeado).

Cambio mínimo sugerido (JS):

// al hacer click en "Seleccionar"
document.getElementById('btn-seleccionar').addEventListener('click', () => {
  const root = document.querySelector('#etapas-container'); // contenedor real de tarjetas
  root.classList.add('select-mode');
  document.querySelectorAll('.task-card input[type="checkbox"]').forEach(cb => cb.hidden = false);
});

// al hacer click en "Cancelar selección"
document.getElementById('btn-cancelar-seleccion').addEventListener('click', () => {
  const root = document.querySelector('#etapas-container');
  root.classList.remove('select-mode');
  document.querySelectorAll('.task-card input[type="checkbox"]').forEach(cb => { cb.checked=false; cb.hidden = true; });
  updateSelectedCount(0);
});

function updateSelectedCount(n){
  document.getElementById('btn-eliminar').querySelector('span.count').textContent = n;
  document.getElementById('btn-asignar').querySelector('span.count').textContent = n;
}

document.addEventListener('change', (e)=>{
  if (e.target.matches('.task-card input[type="checkbox"]')) {
    const n = document.querySelectorAll('.task-card input[type="checkbox"]:checked').length;
    updateSelectedCount(n);
  }
});


CSS mínimo:

.task-card input[type="checkbox"] { display:none; }
.select-mode .task-card input[type="checkbox"] { display:inline-block; }


Criterio de aceptación (UI):

Al tocar Seleccionar, aparecen los checkboxes en todas las tarjetas; los contadores muestran N.

Al tocar Cancelar selección, desaparecen y se resetean contadores.

B) Backend – error al asignar (UnboundLocalError)

Error actual: cannot access local variable 'TareaMiembro' where it is not associated with a value.
Causa típica: se usa el nombre TareaMiembro como variable local dentro de la función, pisando a la clase importada, o no está bien importada.

Pedido:

Asegurar import correcto del modelo y no usar ese nombre para variables.

from models import TareaMiembro  # o donde esté el modelo real


En POST /obras/asignar-usuarios, usar nombres de variables distintos (p.ej. asignacion), leer form-data y devolver JSON.

Hacer upsert (evitar duplicados) y commit.

Handler sugerido (simple):

@obras_bp.post('/obras/asignar-usuarios')
def asignar_usuarios():
    try:
        tarea_ids = request.form.getlist('tarea_ids[]')
        user_ids  = request.form.getlist('user_ids[]')
        cuota     = request.form.get('cuota_objetivo', type=int)

        if not tarea_ids or not user_ids:
            return jsonify(ok=False, error='Faltan tareas o usuarios'), 400

        creados = 0
        for t in tarea_ids:
            for u in user_ids:
                existente = TareaMiembro.query.filter_by(tarea_id=t, user_id=u).first()
                if not existente:
                    asignacion = TareaMiembro(tarea_id=t, user_id=u, cuota=cuota)
                    db.session.add(asignacion)
                    creados += 1

        db.session.commit()
        return jsonify(ok=True, creados=creados)
    except Exception as e:
        current_app.logger.exception('asignar_usuarios')
        db.session.rollback()
        return jsonify(ok=False, error=str(e)), 500


Constraint anti-duplicados (barato y definitivo):

Agregar UniqueConstraint('tarea_id','user_id', name='uq_tarea_user') al modelo TareaMiembro.

Manejar IntegrityError con DO NOTHING (o try/except) para mantener idempotencia.

C) Front de asignación – envío y cookies

Pedido:

Enviar el formulario con FormData y credentials:'include' (no setear Content-Type manualmente).

Si usan Flask-WTF, incluir {{ csrf_token() }} y anexarlo al FormData.

Snippet:

const fd = new FormData(form);
const resp = await fetch(form.action, { method:'POST', body: fd, credentials:'include' });
const data = await resp.json();
if (!resp.ok || data.ok === false) throw new Error(data.error || `HTTP ${resp.status}`);

D) Criterios de aceptación (end-to-end)

UI: “Seleccionar” muestra checkboxes y contadores; “Cancelar selección” los oculta y resetea.

API: /obras/asignar-usuarios responde 200 con {"ok": true, "creados": N} (JSON).

Idempotente: repetir la misma asignación devuelve creados: 0 y no duplica.

UI tareas: aparecen badges con los usuarios asignados.

Operario: al loguear como momi giardina, en /obras/mis-tareas figuran las tareas