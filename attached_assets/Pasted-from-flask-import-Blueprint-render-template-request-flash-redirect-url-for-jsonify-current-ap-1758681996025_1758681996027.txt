from flask import Blueprint, render_template, request, flash, redirect, url_for, jsonify, current_app
from flask_login import login_required, current_user
from datetime import datetime, date
from decimal import Decimal, ROUND_HALF_UP
import requests
from app import db
from sqlalchemy import text
from sqlalchemy import text, func
from sqlalchemy.exc import ProgrammingError
from models import Obra, EtapaObra, TareaEtapa, AsignacionObra, Usuario, CertificacionAvance, TareaResponsables, ObraMiembro, TareaMiembro, TareaAvance, TareaAdjunto, TareaAvanceFoto
from etapas_predefinidas import obtener_etapas_disponibles, crear_etapas_para_obra
from tareas_predefinidas import TAREAS_POR_ETAPA
from geocoding import geocodificar_direccion, normalizar_direccion_argentina
from roles_construccion import obtener_roles_por_categoria, obtener_nombre_rol

obras_bp = Blueprint('obras', __name__)

# Error handlers for AJAX requests to return JSON instead of HTML
@obras_bp.errorhandler(404)
def handle_404(error):
    # Always return JSON for API routes
    if request.path.startswith("/obras/api/"):
        return jsonify({"ok": False, "error": "Not found"}), 404
    # Check if this is an AJAX request (common indicators)
    if request.is_json or 'application/json' in request.headers.get('Accept', ''):
        return jsonify({'ok': False, 'error': 'Recurso no encontrado'}), 404
    # For regular web requests, let Flask handle it normally
    raise error

@obras_bp.errorhandler(500)  
def handle_500(error):
    # Always return JSON for API routes
    if request.path.startswith("/obras/api/"):
@@ -2769,102 +2769,118 @@ def create_obra_etapa(obra_id):


# API Endpoints for Wizard as per user specification

@obras_bp.route('/api/wizard-tareas/preview', methods=['POST'])
@login_required
def wizard_preview():
    """Step 2 - Preview tasks filtered by selected etapas"""
    try:
        data = request.get_json()
        etapa_ids = data.get("etapa_ids", [])
        obra_id = data.get("obra_id")
        
        if not etapa_ids:
            return jsonify({"ok": False, "error": "etapa_ids requeridos"}), 400
            
        if not obra_id:
            return jsonify({"ok": False, "error": "obra_id requerido"}), 400
            
        # Verificar permisos
        obra = Obra.query.get_or_404(obra_id)
        if not can_manage_obra(obra):
            return jsonify({"ok": False, "error": "Sin permisos"}), 403
        
        # üéØ CORRECCI√ìN: etapa_ids son IDs del CAT√ÅLOGO, no de etapas existentes
        from etapas_predefinidas import ETAPAS_CONSTRUCCION
        from tareas_predefinidas import TAREAS_POR_ETAPA
        
        current_app.logger.debug(f"üî• DEBUG WIZARD: Recibidos etapa_ids del cat√°logo: {etapa_ids}")
        current_app.logger.debug(f"üî• DEBUG WIZARD: Total etapas en cat√°logo: {len(ETAPAS_CONSTRUCCION)}")
        
        catalogo = obtener_etapas_disponibles()
        catalogo_por_id = {str(etapa.get("id")): etapa for etapa in catalogo}

        current_app.logger.debug(
            "üî• DEBUG WIZARD: Recibidos etapa_ids del cat√°logo: %s", etapa_ids
        )
        current_app.logger.debug(
            "üî• DEBUG WIZARD: Total etapas en cat√°logo: %s", len(catalogo)
        )

        # üéØ Construir respuesta desde el cat√°logo predefinido
        etapas_data = []
        

        for etapa_id in etapa_ids:
            # Buscar la etapa en el cat√°logo predefinido
            etapa_def = None
            for etapa in ETAPAS_CONSTRUCCION:
                if etapa.get("id") == etapa_id:
                    etapa_def = etapa
                    break
            
            etapa_def = catalogo_por_id.get(str(etapa_id))
            if not etapa_def:
                current_app.logger.warning(f"‚ùå DEBUG WIZARD: Etapa con ID {etapa_id} NO encontrada en cat√°logo")
                current_app.logger.warning(
                    "‚ùå DEBUG WIZARD: Etapa con ID %s NO encontrada en cat√°logo", etapa_id
                )
                continue
                

            etapa_nombre = etapa_def.get("nombre", f"Etapa {etapa_id}")
            current_app.logger.debug(f"‚úÖ DEBUG WIZARD: Procesando etapa del cat√°logo '{etapa_nombre}' (ID: {etapa_id})")
            
            etapa_slug = etapa_def.get("slug")
            current_app.logger.debug(
                "‚úÖ DEBUG WIZARD: Procesando etapa del cat√°logo '%s' (ID: %s, slug: %s)",
                etapa_nombre,
                etapa_def.get("id"),
                etapa_slug,
            )

            # Tareas del cat√°logo por tipo de etapa
            tareas_catalogo = []
            current_app.logger.debug(f"üî• DEBUG WIZARD: Claves disponibles en TAREAS_POR_ETAPA: {list(TAREAS_POR_ETAPA.keys())}")
            
            if etapa_nombre in TAREAS_POR_ETAPA:
                current_app.logger.debug(f"‚úÖ DEBUG WIZARD: Encontrada etapa '{etapa_nombre}' en cat√°logo de tareas")
                current_app.logger.debug(
                    "‚úÖ DEBUG WIZARD: Encontrada etapa '%s' en cat√°logo de tareas", etapa_nombre
                )
                for idx, tarea_def in enumerate(TAREAS_POR_ETAPA[etapa_nombre]):
                    tareas_catalogo.append({
                        "codigo": f"cat_{etapa_id}_{idx}",
                        "codigo": f"cat_{etapa_def.get('id')}_{idx}",
                        "nombre": tarea_def.get("nombre", "Tarea sin nombre"),
                        "unidad_default": tarea_def.get("unidad", "h")
                    })
            else:
                current_app.logger.warning(f"‚ùå DEBUG WIZARD: Etapa '{etapa_nombre}' NO encontrada en TAREAS_POR_ETAPA")
            
                current_app.logger.warning(
                    "‚ùå DEBUG WIZARD: Etapa '%s' NO encontrada en TAREAS_POR_ETAPA",
                    etapa_nombre,
                )

            # Para el wizard, no incluimos tareas existentes ya que estamos creando nuevas
            tareas_existentes = []
            

            etapas_data.append({
                "etapa_id": etapa_id,  # ID del cat√°logo
                "etapa_id": etapa_def.get("id"),  # ID del cat√°logo
                "etapa_slug": etapa_slug,
                "etapa_nombre": etapa_nombre,
                "tareas_catalogo": tareas_catalogo,
                "tareas_existentes": tareas_existentes
            })
            
            current_app.logger.debug(f"üìä DEBUG WIZARD: Etapa {etapa_nombre} - {len(tareas_catalogo)} tareas cat√°logo")
        
        current_app.logger.debug(f"üéØ DEBUG WIZARD: Respuesta final con {len(etapas_data)} etapas")

            current_app.logger.debug(
                "üìä DEBUG WIZARD: Etapa %s - %s tareas cat√°logo",
                etapa_nombre,
                len(tareas_catalogo),
            )

        current_app.logger.debug(
            "üéØ DEBUG WIZARD: Respuesta final con %s etapas", len(etapas_data)
        )
        # üéØ Respuesta con esquema exacto seg√∫n especificaci√≥n del usuario
        return jsonify({
            "ok": True,
            "obra_id": obra_id,
            "etapas": etapas_data
        })
        
    except Exception as e:
        current_app.logger.exception("Error en wizard preview")
        return jsonify({"ok": False, "error": f"Error interno: {str(e)}"}), 500


@obras_bp.route('/api/obras/<int:obra_id>/equipo', methods=['GET'])
@login_required
def get_obra_equipo(obra_id):
    """Get team members for obra (for wizard step 3)"""
    try:
        # Verificar permisos
        obra = Obra.query.get_or_404(obra_id)
        if not can_manage_obra(obra):
            return jsonify({"error": "Sin permisos"}), 403
        
        # Obtener miembros del equipo
        miembros = (ObraMiembro.query
                   .filter_by(obra_id=obra_id)
@@ -2889,132 +2905,245 @@ def get_obra_equipo(obra_id):
@obras_bp.route('/api/wizard-tareas/create', methods=['POST'])
@login_required
def wizard_create():
    """Step 4 - Create tasks in batch with assignments"""
    try:
        data = request.get_json()
        obra_id = data.get("obra_id")
        tareas_in = data.get("tareas", [])
        
        if not obra_id:
            return jsonify({"error": "obra_id requerido"}), 400
            
        if not tareas_in:
            return jsonify({"error": "No hay tareas para crear"}), 400
        
        # Verificar permisos
        obra = Obra.query.get_or_404(obra_id)
        if not can_manage_obra(obra):
            return jsonify({"error": "Sin permisos"}), 403
        
        creadas = []
        duplicados = []
        
        current_app.logger.info(f"üßô‚Äç‚ôÇÔ∏è WIZARD CREATE: Procesando {len(tareas_in)} tareas para obra {obra_id}")
        
        catalogo_etapas = obtener_etapas_disponibles()
        slug_to_nombre = {
            etapa.get('slug'): etapa.get('nombre')
            for etapa in catalogo_etapas
            if etapa.get('slug')
        }
        id_to_nombre = {
            str(etapa.get('id')): etapa.get('nombre')
            for etapa in catalogo_etapas
            if etapa.get('id') is not None
        }
        id_to_slug = {
            str(etapa.get('id')): etapa.get('slug')
            for etapa in catalogo_etapas
            if etapa.get('id') is not None
        }

        def _safe_number(value):
            if value in (None, '', 'null'):
                return None
            try:
                return float(value)
            except (TypeError, ValueError):
                return None

        def _safe_user_id(value):
            if value in (None, '', 'null'):
                return None
            try:
                return int(value)
            except (TypeError, ValueError):
                return None

        # Use proper transaction context
        try:
            for t in tareas_in:
                etapa_slug = t.get("etapa_slug")
                nombre = t.get("nombre")
                
                if not etapa_slug or not nombre:
                nombre = (t.get("nombre") or "").strip()
                etapa_slug = (t.get("etapa_slug") or "").strip() or None
                etapa_catalogo_id_raw = (
                    t.get("etapa_id")
                    or t.get("catalogo_id")
                    or t.get("catalog_id")
                )
                etapa_nombre_payload = (t.get("etapa_nombre") or "").strip() or None

                if not nombre:
                    current_app.logger.warning(
                        "‚ö†Ô∏è WIZARD: Tarea sin nombre descartada (payload: %s)", t
                    )
                    continue
                    
                # Mapear etapa_slug a nombre y buscar etapa_id real
                try:
                    from etapas_predefinidas import obtener_etapas_disponibles
                    catalogo_etapas = obtener_etapas_disponibles()
                    slug_to_nombre = {e['slug']: e['nombre'] for e in catalogo_etapas}

                etapa_catalogo_id = None
                if etapa_catalogo_id_raw not in (None, ""):
                    etapa_catalogo_id = str(etapa_catalogo_id_raw)
                    if not etapa_slug:
                        etapa_slug = id_to_slug.get(etapa_catalogo_id)

                etapa_nombre = None
                if etapa_slug:
                    etapa_nombre = slug_to_nombre.get(etapa_slug)
                    
                    if not etapa_nombre:
                        current_app.logger.warning(f"‚ö†Ô∏è WIZARD: Slug '{etapa_slug}' no encontrado en cat√°logo")
                        continue
                        
                    etapa_real = (EtapaObra.query
                                 .filter(EtapaObra.obra_id == obra_id)
                                 .filter(EtapaObra.nombre == etapa_nombre)
                                 .first())
                except ImportError:
                    current_app.logger.error("‚ùå WIZARD: No se pudo importar etapas_predefinidas")
                if not etapa_nombre and etapa_catalogo_id:
                    etapa_nombre = id_to_nombre.get(etapa_catalogo_id)
                if not etapa_nombre and etapa_nombre_payload:
                    etapa_nombre = etapa_nombre_payload

                if not etapa_nombre:
                    current_app.logger.warning(
                        "‚ö†Ô∏è WIZARD: No se pudo determinar la etapa para '%s' (slug=%s, id=%s)",
                        nombre,
                        etapa_slug,
                        etapa_catalogo_id_raw,
                    )
                    continue
                

                etapa_real = (
                    EtapaObra.query
                    .filter(EtapaObra.obra_id == obra_id)
                    .filter(func.lower(EtapaObra.nombre) == etapa_nombre.lower())
                    .first()
                )

                if not etapa_real and etapa_slug:
                    pattern = f"%{etapa_slug.replace('-', '%')}%"
                    etapa_real = (
                        EtapaObra.query
                        .filter(EtapaObra.obra_id == obra_id)
                        .filter(EtapaObra.nombre.ilike(pattern))
                        .first()
                    )

                if not etapa_real:
                    # Si no existe la etapa, saltamos esta tarea
                    current_app.logger.warning(f"‚ö†Ô∏è WIZARD: Etapa '{etapa_slug}' no encontrada en obra {obra_id}")
                    current_app.logger.warning(
                        "‚ö†Ô∏è WIZARD: Etapa '%s' (slug=%s, id=%s) no encontrada en obra %s",
                        etapa_nombre,
                        etapa_slug,
                        etapa_catalogo_id_raw,
                        obra_id,
                    )
                    continue
                    

                if not etapa_slug:
                    etapa_slug = next(
                        (
                            etapa.get('slug')
                            for etapa in catalogo_etapas
                            if etapa.get('nombre') == etapa_nombre
                        ),
                        None,
                    )

                if not etapa_catalogo_id:
                    etapa_catalogo_id = next(
                        (
                            str(etapa.get('id'))
                            for etapa in catalogo_etapas
                            if etapa.get('slug') == etapa_slug
                        ),
                        None,
                    )

                etapa_id = etapa_real.id
                    

                # Verificar si ya existe (idempotencia)
                exists = (TareaEtapa.query
                         .filter_by(etapa_id=etapa_id, nombre=nombre)
                         .first())
                
                exists = (
                    TareaEtapa.query
                    .filter_by(etapa_id=etapa_id, nombre=nombre)
                    .first()
                )

                if exists:
                    duplicados.append({"etapa_id": etapa_id, "nombre": nombre})
                    current_app.logger.info(f"üìã WIZARD: Tarea duplicada '{nombre}' en etapa {etapa_id}")
                    duplicados.append({
                        "etapa_id": etapa_id,
                        "etapa_slug": etapa_slug,
                        "etapa": etapa_nombre,
                        "nombre": nombre,
                    })
                    current_app.logger.info(
                        "üìã WIZARD: Tarea duplicada '%s' en etapa %s",
                        nombre,
                        etapa_id,
                    )
                    continue
                

                # Parsear fechas
                fecha_inicio = None
                fecha_fin = None
                

                if t.get("fecha_inicio"):
                    try:
                        fecha_inicio = datetime.strptime(t["fecha_inicio"], '%Y-%m-%d').date()
                    except ValueError:
                        pass
                        
                if t.get("fecha_fin"):
                    try:
                        fecha_fin = datetime.strptime(t["fecha_fin"], '%Y-%m-%d').date()
                    except ValueError:
                        pass
                

                horas_estimadas = _safe_number(t.get("horas"))
                cantidad_planificada = _safe_number(t.get("cantidad"))
                asignado_usuario_id = _safe_user_id(t.get("asignado_usuario_id"))

                # Crear tarea
                tarea = TareaEtapa(
                    etapa_id=etapa_id,
                    nombre=nombre,
                    descripcion=f"Creada via wizard masivo",
                    estado='pendiente',
                    unidad=t.get("unidad", "h"),
                    unidad=(t.get("unidad") or "h"),
                    fecha_inicio_plan=fecha_inicio,
                    fecha_fin_plan=fecha_fin,
                    horas_estimadas=t.get("horas"),
                    cantidad_planificada=t.get("cantidad"),
                    responsable_id=t.get("asignado_usuario_id")
                    horas_estimadas=horas_estimadas,
                    cantidad_planificada=cantidad_planificada,
                    responsable_id=asignado_usuario_id,
                )
                

                db.session.add(tarea)
                db.session.flush()  # Para obtener el ID
                

                # Asignar usuario en tarea_miembros si viene asignado_usuario_id
                if t.get("asignado_usuario_id"):
                if asignado_usuario_id:
                    asignacion = TareaMiembro(
                        tarea_id=tarea.id,
                        usuario_id=t["asignado_usuario_id"]
                        usuario_id=asignado_usuario_id,
                    )
                    db.session.add(asignacion)
                
                creadas.append({"id": tarea.id, "nombre": tarea.nombre})
                current_app.logger.info(f"‚ú® WIZARD: Tarea creada '{nombre}' ID:{tarea.id}")

                creadas.append({
                    "id": tarea.id,
                    "nombre": tarea.nombre,
                    "etapa_id": etapa_id,
                    "etapa_slug": etapa_slug,
                    "etapa": etapa_nombre,
                })
                current_app.logger.info(
                    "‚ú® WIZARD: Tarea creada '%s' ID:%s (etapa=%s)",
                    nombre,
                    tarea.id,
                    etapa_nombre,
                )
            
            # Confirmar transacci√≥n
            db.session.commit()
            current_app.logger.info(f"üéâ WIZARD CREATE: {len(creadas)} creadas, {len(duplicados)} duplicadas")
            
            return jsonify({
                "ok": True,
                "creadas": creadas,
                "duplicados": duplicados
            })
            
        except Exception as e:
            db.session.rollback()
            current_app.logger.exception("Error en transacci√≥n wizard create")
            raise e
        
    except Exception as e:
        current_app.logger.exception("Error en wizard create")
        return jsonify({"error": f"Error interno: {str(e)}"}), 500
static/js/wizard.js
+128
-27

@@ -427,103 +427,161 @@ function rehydrateChecksFromState() {
    });
  updateEtapasBadge();
  console.log(`üéØ STATE: Rehidratados ${window.WZ_STATE.etapasSel.size} checkboxes desde estado global`);
}

// Opciones/equipos
window.ensureOpciones = async function (obraId) {
  if (window.WZ_STATE.opciones) return window.WZ_STATE.opciones;

  try {
    const data = await fetchJSON(api(`obras/api/wizard-tareas/opciones?obra_id=${obraId}`));
    window.WZ_STATE.opciones = data;
    return data;
    
  } catch (error) {
    console.error('‚ùå WIZARD: Error cargando opciones:', error);
    return { unidades: ['h'], usuarios: [], equipo: [] };
  }
};

// collectPaso3Payload - Recopilar datos del Paso 3
window.collectPaso3Payload = function() {
  const modal = document.getElementById('wizardTareasModal');
  const rows = [...modal.querySelectorAll('#wizardStep3 #tablaDatosWizard tbody tr, #paso3 #tablaDatosWizard tbody tr')];
  const obraId = Number(modal?.getAttribute('data-obra-id') || window.OBRA_ID || 0);
  

  const etapaCatalogo = [
    ...(window.WIZARD?.preview?.etapas || []),
    ...(window.WIZARD?.catalogo || []),
  ];

  const findEtapaInfo = (slug, catalogId) => {
    const catalogIdStr = catalogId != null ? String(catalogId) : null;
    return etapaCatalogo.find(etapa => {
      if (!etapa) return false;
      const etapaSlug = etapa.etapa_slug || etapa.slug;
      const etapaId = etapa.etapa_id ?? etapa.id;
      const slugMatches = slug && etapaSlug && etapaSlug === slug;
      const idMatches = catalogIdStr && etapaId != null && String(etapaId) === catalogIdStr;
      return slugMatches || idMatches;
    }) || null;
  };

  const toNumberOrNull = (value) => {
    if (value === undefined || value === null || value === '' || value === 'null') {
      return null;
    }
    const num = Number(value);
    return Number.isFinite(num) ? num : null;
  };

  const toIntOrNull = (value) => {
    if (value === undefined || value === null || value === '' || value === 'null') {
      return null;
    }
    const num = parseInt(value, 10);
    return Number.isFinite(num) ? num : null;
  };

  const tareas = rows.map((row, i) => {
    const getData = (name) => row.querySelector(`[name="rows[${i}][${name}]"]`)?.value || '';
    const tareaData = window.WZ_STATE.tareasSel?.[i] || {};
    
    const etapaInfo = findEtapaInfo(
      tareaData.etapa_slug,
      tareaData.etapa_catalog_id ?? tareaData.etapa_id ?? tareaData.etapa_catalog_id_raw
    );

    const etapaCatalogId = (
      tareaData.etapa_catalog_id ??
      tareaData.etapa_id ??
      etapaInfo?.etapa_id ??
      etapaInfo?.id ??
      null
    );

    const etapaIdNumber = toNumberOrNull(etapaCatalogId);
    const etapaSlug = tareaData.etapa_slug || etapaInfo?.etapa_slug || etapaInfo?.slug || '';
    const etapaNombre = tareaData.etapa_nombre || etapaInfo?.etapa_nombre || etapaInfo?.nombre || '';
    const asignadoId = toIntOrNull(getData('asignado'));
    const unidad = getData('unidad') || 'h';
    const horasValor = toNumberOrNull(getData('horas'));
    const cantidadValor = toNumberOrNull(getData('cantidad'));

    return {
      etapa_slug: tareaData.etapa_slug || '',  // Usar slug de la plantilla
      etapa_slug: etapaSlug,
      etapa_id: etapaIdNumber,
      catalogo_id: etapaIdNumber,
      etapa_nombre: etapaNombre,
      nombre: row.children[1]?.textContent?.trim() || '',
      fecha_inicio: getData('inicio'),
      fecha_fin: getData('fin'),
      horas: Number(getData('horas')) || 8,
      cantidad: Number(getData('cantidad')) || 1,
      unidad: getData('unidad'),
      asignado_usuario_id: getData('asignado') || null,
      horas: horasValor == null ? 8 : horasValor,
      cantidad: cantidadValor == null ? 1 : cantidadValor,
      unidad,
      asignado_usuario_id: asignadoId,
      prioridad: getData('prioridad') || 'media'
    };
  });
  

  return {
    obra_id: obraId,
    tareas: tareas.filter(t => t.etapa_slug)  // Filtrar tareas con etapa_slug v√°lido
    tareas: tareas.filter(t => t.etapa_slug || t.etapa_id != null)  // Filtrar tareas con informaci√≥n de etapa v√°lida
  };
};

// populatePaso3 - BLOQUE CAN√ìNICO
window.populatePaso3 = async function() {
  const modal = document.getElementById('wizardTareasModal');
  const tbody = modal.querySelector('#tablaDatosWizard tbody');
  const obraId = modal.dataset.obraId || window.obraId;
  
  if (!tbody || !window.WZ_STATE.tareasSel?.length) {
    console.warn('‚ö†Ô∏è WIZARD: No hay tareas seleccionadas o tabla no encontrada');
    return;
  }

  // Cargar opciones (unidades y equipo) - Ruta absoluta
  const opciones = await window.ensureOpciones(obraId);
  const unidades = opciones.unidades || ['h', 'd√≠as', 'und'];
  const equipo = opciones.usuarios || opciones.equipo || [];  // Fix: Backend returns 'usuarios', not 'equipo'

  // Generar filas
  const filas = window.WZ_STATE.tareasSel.map((tarea, i) => {
    const unidadesOpts = unidades.map(u => `<option value="${u}">${u}</option>`).join('');
    

    // Modificaci√≥n: Agregar placeholder y no pre-seleccionar usuario
    const equipoOpts = [
      '<option value="">‚Äî Seleccion√° ‚Äî</option>',  // Placeholder
      ...equipo.map(user => `<option value="${user.id}">${user.nombre}</option>`)
    ].join('');

    const etapaLabel = tarea.etapa_nombre || tarea.etapa_slug || 'Sin etapa';

    return `
      <tr data-index="${i}">
        <td class="small text-muted">${tarea.etapa_slug || 'Sin etapa'}</td>
        <td class="small text-muted">${etapaLabel}</td>
        <td class="fw-bold">${tarea.nombre}</td>
        <td><input type="date" name="rows[${i}][inicio]" class="form-control form-control-sm"></td>
        <td><input type="date" name="rows[${i}][fin]" class="form-control form-control-sm"></td>
        <td><input type="number" name="rows[${i}][horas]" value="8" min="1" class="form-control form-control-sm" style="width:70px"></td>
        <td><input type="number" name="rows[${i}][cantidad]" value="1" min="1" class="form-control form-control-sm" style="width:70px"></td>
        <td>
          <select name="rows[${i}][unidad]" class="form-select form-select-sm" style="width:80px">
            ${unidadesOpts}
          </select>
        </td>
        <td>
          <select name="rows[${i}][asignado]" class="form-select form-select-sm" style="min-width:120px">
            ${equipoOpts}
          </select>
        </td>
        <td>
          <select name="rows[${i}][prioridad]" class="form-select form-select-sm" style="width:90px">
            <option value="baja">Baja</option>
            <option value="media" selected>Media</option>
            <option value="alta">Alta</option>
          </select>
        </td>
      </tr>
    `;
  }).join('');
@@ -536,84 +594,113 @@ window.populatePaso3 = async function() {
window.loadTareasWizard = async function(obraId, slugs) {
  console.log(`üî• WIZARD: Cargando tareas del CAT√ÅLOGO para obra ${obraId}, etapas:`, slugs);
  
  const m = document.getElementById('wizardTareasModal');
  const list = m.querySelector('#wizardListaTareas') || m.querySelector('#wizardStep2');
  const spin = m.querySelector('#wizardSpinnerTareas');
  
  console.log(`üîç WIZARD: Contenedores encontrados - Modal: ${!!m}, ListaTareas: ${!!list}, Spinner: ${!!spin}`);
  console.log(`üîç WIZARD: Selector usado: #wizardListaTareas`);
  
  if (spin) spin.classList.remove('d-none');
  if (list) {
    list.innerHTML = '';
    console.log(`üîç WIZARD: Lista limpiada. Contenedor actual:`, list);
  }
  
  try {
    // USAR EL ENDPOINT DEL CAT√ÅLOGO (NO DB REAL) - Ruta absoluta
    const json = await fetchJSON(api(`obras/api/wizard-tareas/tareas?obra_id=${obraId}&etapas=${encodeURIComponent(JSON.stringify(slugs))}`), {
      method: 'POST',
      headers: {'Content-Type':'application/json'},
      body: JSON.stringify({ obra_id: parseInt(obraId), etapas: slugs })
    });
    
    const tareas = json.tareas_catalogo || json.tareas || json.data || [];

    const slugToEtapaMeta = new Map();
    const registerEtapaMeta = (slug, meta = {}) => {
      if (!slug) return;
      const current = slugToEtapaMeta.get(slug) || {};
      const catalogId = meta.etapa_id ?? meta.id;
      slugToEtapaMeta.set(slug, {
        id: catalogId != null ? catalogId : current.id ?? null,
        nombre: meta.etapa_nombre || meta.nombre || current.nombre || '',
        slug,
      });
    };

    (window.WIZARD?.preview?.etapas || []).forEach(etapa => {
      registerEtapaMeta(etapa?.etapa_slug || etapa?.slug, etapa);
    });
    (window.WIZARD?.catalogo || []).forEach(etapa => {
      registerEtapaMeta(etapa?.slug, etapa);
    });

    const escapeAttr = (value) => String(value ?? '').replace(/"/g, '&quot;');
    
    console.log(`üîç WIZARD: Datos recibidos del backend:`, { 
      json, 
      tareasExtracted: tareas,
      primerasTareas: tareas.slice(0, 3)
    });
    
    if (spin) spin.classList.add('d-none');
    
    if (list) {
      const html = tareas.length
        ? `<div class="mb-3">
             <h6 class="text-primary">üìã Plantillas disponibles (${tareas.length}):</h6>
             <div class="row">${
               tareas.map((t, index) => {
                 console.log(`üîç WIZARD: Generando checkbox ${index}:`, { 
                   tarea: t, 
                   id: t.id, 
                   nombre: t.nombre, 
                   etapaSlug: t.etapa_slug 
                 const etapaSlug = t.etapa_slug || '';
                 const etapaMeta = slugToEtapaMeta.get(etapaSlug) || {};
                 const etapaCatalogIdAttr = etapaMeta.id != null ? etapaMeta.id : '';
                 const etapaNombreAttr = etapaMeta.nombre || '';
                 console.log(`üîç WIZARD: Generando checkbox ${index}:`, {
                   tarea: t,
                   id: t.id,
                   nombre: t.nombre,
                   etapaSlug,
                   etapaCatalogId: etapaCatalogIdAttr,
                   etapaNombre: etapaNombreAttr,
                 });
                 

                 return `
                   <div class="col-md-6 mb-2">
                     <div class="form-check">
                       <input class="form-check-input tarea-checkbox" type="checkbox" 
                              name="tasks[]"
                              data-id="${t.id || ''}" 
                              data-nombre="${t.nombre || ''}"
                              data-etapa="${t.etapa_slug || ''}"
                              data-descripcion="${t.descripcion || ''}"
                              data-horas="${t.horas || '8'}"
                              value="${t.id || ''}"
                              id="tarea-${t.id || index}">
                        <input class="form-check-input tarea-checkbox" type="checkbox"
                               name="tasks[]"
                               data-id="${t.id || ''}"
                               data-nombre="${t.nombre || ''}"
                               data-etapa="${t.etapa_slug || ''}"
                               data-etapa-id="${escapeAttr(etapaCatalogIdAttr)}"
                               data-etapa-nombre="${escapeAttr(etapaNombreAttr)}"
                               data-descripcion="${t.descripcion || ''}"
                               data-horas="${t.horas || '8'}"
                               value="${t.id || ''}"
                               id="tarea-${t.id || index}">
                       <label class="form-check-label" for="tarea-${t.id || index}">
                         <strong>${t.nombre || 'Tarea sin nombre'}</strong>
                         ${t.descripcion ? `<br><small class="text-muted">${t.descripcion}</small>` : ''}
                         <small class="text-info d-block">‚è±Ô∏è ${t.horas || 0}h estimadas</small>
                       </label>
                     </div>
                   </div>
                 `;
               }).join('')
             }</div>
           </div>`
        : '<div class="text-muted text-center p-4">üìù No hay plantillas disponibles para las etapas seleccionadas.</div>';
      
      list.innerHTML = html;
      
      // üî• REBINDEAR EVENT LISTENERS para tareas (CR√çTICO para panel "Tareas Seleccionadas")
      setTimeout(() => {
        document.querySelectorAll('.tarea-checkbox').forEach(checkbox => {
          checkbox.addEventListener('change', updateTaskSelectionPanel);
        });
        // üî• INICIALIZAR panel al cargar
        updateTaskSelectionPanel();
        console.log('‚úÖ WIZARD: Event listeners de tareas rebindeados');
      }, 50);
      
@@ -722,57 +809,71 @@ function setupUniqueInterceptor() {
          window.loadTareasWizard(obraId, slugs);
        } else {
          console.error('‚ùå WIZARD: No se puede cargar tareas - obraId:', obraId, 'slugs:', slugs);
        }
      }, 100);
      
    } else if (paso2Visible || currentStep === 2) {
      // PASO 2 ‚Üí 3: Capturar tareas seleccionadas del cat√°logo
      console.log(`üîç WIZARD: Iniciando captura Paso 2 ‚Üí 3`);
      
      // üéØ DEBUG: No contar DOM checkboxes, usar informaci√≥n de estado
      console.log(`üîç WIZARD: Estado actual:`, {
        etapasEnSet: window.WZ_STATE?.etapasSel?.size || 0,
        mensaje: 'Debug migrado a Set-based approach'
      });
      
      // üéØ DEBUG REMOVED: Ya no usar todosCheckboxes ni tareasSeleccionadas del DOM
      
      // üéØ VALIDATION: Usar estado de tareas seleccionadas - defer to Paso 3 validation
      // tareasSeleccionadas no est√° disponible como DOM collection aqu√≠
      console.log('üîç WIZARD: Validaci√≥n de tareas diferida al Paso 3');
      
      // üéØ CAPTURAR TAREAS EN WZ_STATE.tareasSel
      window.WZ_STATE = window.WZ_STATE || {};
      window.WZ_STATE.tareasSel = [];
      

      // üéØ COLLECT TASKS: Buscar tareas checked en DOM, pero no depender del estado checked
      document.querySelectorAll('.tarea-checkbox:checked:not(:disabled)').forEach(checkbox => {
        const etapaNombreAttr = checkbox.getAttribute('data-etapa-nombre') || '';
        const etapaCatalogAttr = checkbox.getAttribute('data-etapa-id');
        let etapaCatalogId = null;
        if (etapaCatalogAttr && etapaCatalogAttr !== 'null') {
          const parsed = Number(etapaCatalogAttr);
          if (Number.isFinite(parsed)) {
            etapaCatalogId = parsed;
          }
        }

        const tareaData = {
          id: checkbox.getAttribute('data-id') || '',
          nombre: checkbox.getAttribute('data-nombre') || checkbox.nextElementSibling?.textContent?.trim() || 'Tarea sin nombre',
          etapa_slug: checkbox.getAttribute('data-etapa') || '',
          etapa_nombre: etapaNombreAttr,
          etapa_catalog_id: etapaCatalogId,
          etapa_id: etapaCatalogId,
          etapa_catalog_id_raw: etapaCatalogAttr,
          descripcion: checkbox.getAttribute('data-descripcion') || '',
          horas: checkbox.getAttribute('data-horas') || '8'
        };
        window.WZ_STATE.tareasSel.push(tareaData);
      });
      
      console.log(`üéØ WIZARD: ${window.WZ_STATE.tareasSel.length} tareas capturadas del cat√°logo:`, window.WZ_STATE.tareasSel);
      
      // Navegar al Paso 3 y popularlo
      console.log('üî• WIZARD: Navegando Paso 2 ‚Üí 3');
      window.WZ_STATE.currentStep = 3;
      window.gotoPaso?.(3);
      
      // Poblar el Paso 3 con las tareas seleccionadas
      setTimeout(() => {
        if (typeof window.populatePaso3 === 'function') {
          window.populatePaso3();
        }
      }, 100);
      
    } else if (currentStep === 3) {
      // PASO 3: Cambiar bot√≥n a "Confirmar" y preparar finalizaci√≥n
      console.log('üîç WIZARD: Detectando Paso 3 - cambiando bot√≥n a Confirmar');
      
      // Validar que los campos requeridos est√©n completos