OBYRA IA — Marketplace por Producto + Portal Proveedor + Comisión 2%
Stack (obligatorio)

Backend: Flask, SQLAlchemy, Alembic, Flask-WTF (CSRF), Werkzeug (hash)

DB: PostgreSQL

Render: Jinja2 (SSR)

Archivos: local static/uploads o S3/MinIO por env

PDF: WeasyPrint (Factura de Comisión)

Auth: usuarios existentes (compradores) + auth de proveedor (nueva)

Objetivo

Portal de Proveedores: registro/login, perfil, alta/edición de productos y variantes (precio, unidad, stock, atributos), imágenes, Q&A, RFQ/Órdenes.

Marketplace producto-céntrico: catálogo público por producto con precio visible, carrito y compra directa.

Comisión 2%: OBYRA cobra 2% por orden:

A. Online (recomendado): Mercado Pago split (application_fee = 2%).

B. Offline: el proveedor marca pago, sube su factura al cliente y OBYRA emite factura de comisión.

Modelado de datos (SQLAlchemy)

Importes/stock usar Numeric(12,2); para atributos usar JSON.
En ProductVariant el campo correcto es atributos_json.

# models.py (extracto)
from sqlalchemy import Numeric, JSON

class Supplier(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    razon_social = db.Column(db.String(160), nullable=False)
    cuit = db.Column(db.String(32), nullable=False)
    email = db.Column(db.String(160))
    phone = db.Column(db.String(64))
    direccion = db.Column(db.String(200))
    descripcion = db.Column(db.Text)
    ubicacion = db.Column(db.String(120))
    estado = db.Column(db.Enum('activo','suspendido', name='supplier_estado'), default='activo')
    verificado = db.Column(db.Boolean, default=False)
    mp_collector_id = db.Column(db.String(64))  # para split MP
    created_at = db.Column(db.DateTime, server_default=db.func.now())

class SupplierUser(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    supplier_id = db.Column(db.Integer, db.ForeignKey('supplier.id'), nullable=False)
    nombre = db.Column(db.String(120))
    email = db.Column(db.String(160), unique=True, nullable=False)
    password_hash = db.Column(db.String(255), nullable=False)
    rol = db.Column(db.Enum('owner','editor', name='supplier_user_rol'), default='owner')
    activo = db.Column(db.Boolean, default=True)
    last_login = db.Column(db.DateTime)

class Category(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    nombre = db.Column(db.String(120), nullable=False)
    parent_id = db.Column(db.Integer, db.ForeignKey('category.id'))

class Product(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    supplier_id = db.Column(db.Integer, db.ForeignKey('supplier.id'), nullable=False)
    category_id = db.Column(db.Integer, db.ForeignKey('category.id'))
    nombre = db.Column(db.String(160), nullable=False)
    slug = db.Column(db.String(180), unique=True)     # SEO
    descripcion = db.Column(db.Text)
    estado = db.Column(db.Enum('borrador','publicado','pausado', name='product_estado'), default='borrador')
    rating_prom = db.Column(Numeric(2,1))
    published_at = db.Column(db.DateTime)
    visitas = db.Column(db.Integer, default=0)
    created_at = db.Column(db.DateTime, server_default=db.func.now())
    updated_at = db.Column(db.DateTime, onupdate=db.func.now())

class ProductVariant(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    product_id = db.Column(db.Integer, db.ForeignKey('product.id'), nullable=False)
    sku = db.Column(db.String(64), unique=True, nullable=False)
    atributos_json = db.Column(JSON, default={})  # {"presentacion":"50kg","color":"gris"}
    unidad = db.Column(db.String(16), nullable=False)   # u, kg, m, m2, etc.
    precio = db.Column(Numeric(12,2), nullable=False)
    moneda = db.Column(db.String(8), default='ARS')
    stock = db.Column(Numeric(12,2), default=0, nullable=False)
    visible = db.Column(db.Boolean, default=True)

class ProductImage(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    product_id = db.Column(db.Integer, db.ForeignKey('product.id'), nullable=False)
    url = db.Column(db.String(255), nullable=False)
    filename = db.Column(db.String(160))
    orden = db.Column(db.Integer, default=0)

class ProductQnA(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    product_id = db.Column(db.Integer, db.ForeignKey('product.id'), nullable=False)
    user_id = db.Column(db.Integer)  # comprador
    pregunta = db.Column(db.Text, nullable=False)
    respuesta = db.Column(db.Text)
    created_at = db.Column(db.DateTime, server_default=db.func.now())

# Carrito
class Cart(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    user_id = db.Column(db.Integer)       # si está logueado
    session_id = db.Column(db.String(64)) # visitante anónimo (cookie)
    created_at = db.Column(db.DateTime, server_default=db.func.now())

class CartItem(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    cart_id = db.Column(db.Integer, db.ForeignKey('cart.id'), nullable=False)
    product_variant_id = db.Column(db.Integer, db.ForeignKey('product_variant.id'), nullable=False)
    supplier_id = db.Column(db.Integer, db.ForeignKey('supplier.id'), nullable=False)
    qty = db.Column(Numeric(12,2), nullable=False)
    precio_snapshot = db.Column(Numeric(12,2), nullable=False)

class Order(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    company_id = db.Column(db.Integer)   # comprador
    supplier_id = db.Column(db.Integer, db.ForeignKey('supplier.id'), nullable=False)
    total = db.Column(Numeric(12,2), nullable=False)
    moneda = db.Column(db.String(8), default='ARS')
    estado = db.Column(db.Enum('pendiente','pagado','entregado','cancelado', name='order_estado'), default='pendiente')
    payment_method = db.Column(db.Enum('online','offline', name='order_payment_method'))
    payment_status = db.Column(db.Enum('init','approved','rejected','refunded', name='order_payment_status'), default='init')
    payment_ref = db.Column(db.String(120))
    buyer_invoice_url = db.Column(db.String(255))
    supplier_invoice_number = db.Column(db.String(80))
    supplier_invoice_url = db.Column(db.String(255))
    shipping_address = db.Column(JSON)
    billing_info = db.Column(JSON)
    created_at = db.Column(db.DateTime, server_default=db.func.now())

class OrderItem(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    order_id = db.Column(db.Integer, db.ForeignKey('order.id'), nullable=False)
    product_variant_id = db.Column(db.Integer, db.ForeignKey('product_variant.id'), nullable=False)
    qty = db.Column(Numeric(12,2), nullable=False)
    precio_unit = db.Column(Numeric(12,2), nullable=False)
    subtotal = db.Column(Numeric(12,2), nullable=False)

class OrderCommission(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    order_id = db.Column(db.Integer, db.ForeignKey('order.id'), nullable=False)
    base = db.Column(Numeric(12,2), nullable=False)
    rate = db.Column(Numeric(5,4), default=0.02)
    monto = db.Column(Numeric(12,2), nullable=False)
    iva = db.Column(Numeric(12,2), nullable=False)
    total = db.Column(Numeric(12,2), nullable=False)
    status = db.Column(db.Enum('pendiente','facturado','cobrado','anulado', name='commission_status'), default='pendiente')
    invoice_number = db.Column(db.String(64))
    invoice_pdf_url = db.Column(db.String(255))
    created_at = db.Column(db.DateTime, server_default=db.func.now())


Índices

supplier_user.email UNIQUE

product.slug UNIQUE; product (estado, category_id, published_at)

product_variant (product_id, visible) y sku UNIQUE

order (supplier_id, estado, payment_status)

Reglas de publicación de producto

Para publicar:

≥1 imagen

≥1 variante visible con precio > 0 y stock ≥ 0

category_id seteado

SKU global único.

Cambios de precio/stock impactan al instante.

Rutas y Blueprints
Público (comprador)

GET /market/productos → listado con búsqueda por texto y filtros: categoria, precio_min/max, ubicacion(proveedor), rating, verificado.

GET /p/<slug> → detalle de producto (variantes, precio, stock, imágenes, Q&A, proveedor) + Agregar al carrito.

Carrito

GET /cart

POST /cart/add (variant_id, qty)

POST /cart/update / POST /cart/remove

Checkout

GET /checkout → agrupar ítems por proveedor

POST /checkout/confirm → crea N órdenes (una por proveedor), copia precio_snapshot, valida stock.

GET /order/<id> → estado, pago, adjuntos

Autenticación proveedor (/proveedor)

GET/POST /proveedor/registro (crea Supplier + SupplierUser(owner))

GET/POST /proveedor/login / POST /proveedor/logout

Sesión: session['supplier_user_id'], session['supplier_id']

Portal proveedor (login requerido)

GET /proveedor/ (dashboard: KPIs + últimos pedidos)

GET/POST /proveedor/perfil

Productos

GET /proveedor/productos

GET/POST /proveedor/productos/nuevo

GET/POST /proveedor/productos/<id>/editar

POST /proveedor/productos/<id>/(publicar|pausar|borrar)

Variantes

POST /proveedor/productos/<id>/variantes/nueva

POST /proveedor/variantes/<id>/(editar|pausar|publicar|eliminar)

Imágenes

POST /proveedor/productos/<id>/imagenes/subir

POST /proveedor/imagenes/<id>/(orden|eliminar)

Órdenes

GET /proveedor/ordenes / GET /proveedor/ordenes/<id>

Offline: subir factura del cliente + “Marcar pago recibido”

Admin

GET /admin/productos (moderación)

GET /admin/liquidaciones (comisiones pendiente/facturado/cobrado)

Lógica de carrito/checkout (handlers mínimos)
# blueprints/cart.py (extracto)
from decimal import Decimal
from flask import Blueprint, request, redirect, url_for, session, render_template, jsonify
from app import db
from models import Cart, CartItem, ProductVariant, Supplier, Order, OrderItem

bp = Blueprint("cart", __name__)

def _get_or_create_cart():
    sid = session.get("sid")
    if not sid:
        import uuid; sid = uuid.uuid4().hex; session["sid"] = sid
    cart = Cart.query.filter_by(session_id=sid).first()
    if not cart:
        cart = Cart(session_id=sid); db.session.add(cart); db.session.commit()
    return cart

@bp.post("/cart/add")
def add_to_cart():
    cart = _get_or_create_cart()
    var_id = int(request.form["variant_id"]); qty = Decimal(request.form.get("qty","1"))
    var = ProductVariant.query.get_or_404(var_id)
    item = CartItem(cart_id=cart.id, product_variant_id=var.id,
                    supplier_id=var.product.supplier_id,
                    qty=qty, precio_snapshot=var.precio)
    db.session.add(item); db.session.commit()
    return redirect(url_for("cart.view_cart"))

@bp.get("/cart")
def view_cart():
    cart = _get_or_create_cart()
    items = CartItem.query.filter_by(cart_id=cart.id).all()
    return render_template("cart/view.html", items=items)

@bp.post("/checkout/confirm")
def checkout_confirm():
    cart = _get_or_create_cart()
    items = CartItem.query.filter_by(cart_id=cart.id).all()
    # agrupar por supplier
    from collections import defaultdict
    groups = defaultdict(list)
    for it in items: groups[it.supplier_id].append(it)

    created_orders = []
    for supplier_id, gitems in groups.items():
        order = Order(supplier_id=supplier_id, payment_method='online', payment_status='init', estado='pendiente',
                      total=sum([it.precio_snapshot*it.qty for it in gitems]))
        db.session.add(order); db.session.flush()
        for it in gitems:
            var = ProductVariant.query.get(it.product_variant_id)
            if var.stock < it.qty:
                db.session.rollback()
                return render_template("cart/stock_error.html", variant=var)
            var.stock -= it.qty
            oi = OrderItem(order_id=order.id, product_variant_id=var.id,
                           qty=it.qty, precio_unit=it.precio_snapshot,
                           subtotal=it.precio_snapshot*it.qty)
            db.session.add(oi)
        created_orders.append(order.id)
    # limpiar carrito
    CartItem.query.filter_by(cart_id=cart.id).delete()
    db.session.commit()
    # redirigir a la primera orden (o listado)
    return redirect(url_for("orders.view_order", order_id=created_orders[0]))

Pago y Comisión 2%
A. Mercado Pago split (recomendado)
# blueprints/payments.py (extracto)
from flask import Blueprint, request, redirect, url_for, current_app, jsonify
import requests, os, decimal
from app import db
from models import Order, OrderCommission
bp = Blueprint("payments", __name__)

PLATFORM_COMMISSION_RATE = decimal.Decimal(os.getenv("PLATFORM_COMMISSION_RATE","0.02"))

@bp.post("/market/orden/<int:order_id>/checkout")
def create_checkout(order_id):
    order = Order.query.get_or_404(order_id)
    application_fee = (order.total * PLATFORM_COMMISSION_RATE).quantize(decimal.Decimal("0.01"))
    payload = {
        "items":[{"title":f"Orden #{order.id}", "quantity":1, "unit_price": float(order.total)}],
        "marketplace_fee": float(application_fee),
        "metadata":{"order_id": order.id, "supplier_id": order.supplier_id},
        "notification_url": os.getenv("MP_WEBHOOK_URL"),
        "statement_descriptor": "OBYRA IA",
        "auto_return":"approved",
        "payer":{}
    }
    # collector_id del proveedor (split)
    headers={"Authorization": f"Bearer {os.getenv('MP_ACCESS_TOKEN')}"}
    r = requests.post("https://api.mercadopago.com/checkout/preferences", json=payload, headers=headers, timeout=20)
    r.raise_for_status()
    init_point = r.json()["init_point"]
    return redirect(init_point)

@bp.post("/webhooks/mp")
def mp_webhook():
    data = request.get_json() or {}
    # mapear payment -> order_id (metadata)
    # obtener estado aprobado; luego:
    order_id = int((data.get("data") or {}).get("order_id") or data.get("order_id", 0))
    order = Order.query.get(order_id)
    if not order: return jsonify({"ok":True})
    order.payment_status = 'approved'; order.estado='pagado'; order.payment_ref=str(data.get("id") or data.get("payment_id"))
    db.session.commit()
    # generar Factura de Comisión
    from services.commission import generate_commission_invoice
    generate_commission_invoice(order.id, PLATFORM_COMMISSION_RATE)
    return jsonify({"ok": True})

B. Offline

En /proveedor/ordenes/<id>: botones “Subir factura al cliente” y “Marcar pago recibido”.

Backend: crea/actualiza OrderCommission (status='pendiente').

Admin o link MP simple para cobrar comisión → status='cobrado'.

Servicio PDF de Comisión
# services/commission.py
from weasyprint import HTML
from flask import render_template
from decimal import Decimal
from models import Order, OrderCommission
from app import db
from os import makedirs
from os.path import dirname

def generate_commission_invoice(order_id, rate: Decimal, iva_rate: Decimal = Decimal("0.21")):
    order = Order.query.get(order_id)
    base = order.total
    monto = (base * rate).quantize(Decimal("0.01"))
    iva = (monto * iva_rate).quantize(Decimal("0.01"))
    total = (monto + iva).quantize(Decimal("0.01"))

    oc = OrderCommission.query.filter_by(order_id=order.id).first() or OrderCommission(order_id=order.id, rate=rate)
    oc.base, oc.monto, oc.iva, oc.total, oc.status = base, monto, iva, total, 'facturado'
    if not oc.invoice_number: oc.invoice_number = f"OC-{order.id:06d}"
    db.session.add(oc); db.session.commit()

    html = render_template("pdf/commission_invoice.html", order=order, oc=oc, supplier=order.supplier)
    pdf = HTML(string=html).write_pdf()
    path = f"static/uploads/invoices/{oc.invoice_number}.pdf"
    makedirs(dirname(path), exist_ok=True)
    with open(path, "wb") as f: f.write(pdf)
    oc.invoice_pdf_url = f"/{path}"; db.session.commit()
    return oc


Plantilla mínima: templates/pdf/commission_invoice.html (logo OBYRA, datos proveedor, orden, base, % comisión, IVA, total, fecha, número).

Plantillas mínimas (para destrabar)

Registro proveedor – templates/proveedor/registro.html

<form method="post">
  {{ csrf_token() }}
  <input name="razon_social" placeholder="Razón social" required>
  <input name="cuit" placeholder="CUIT" required>
  <input name="email" type="email" placeholder="Email" required>
  <input name="password" type="password" placeholder="Contraseña" required>
  <button type="submit">Crear cuenta</button>
</form>


Login proveedor – templates/proveedor/login.html

<form method="post">
  {{ csrf_token() }}
  <input name="email" type="email" placeholder="Email" required>
  <input name="password" type="password" placeholder="Contraseña" required>
  <button type="submit">Ingresar</button>
</form>


Listado público de productos – templates/market/products.html

<h1>Productos</h1>
<form method="get">
  <input name="q" value="{{ request.args.get('q','') }}" placeholder="Buscar...">
  <!-- filtros categoría/ubicación/precio -->
  <button>Buscar</button>
</form>
<div class="grid">
  {% for p in productos %}
  <a href="{{ url_for('market.product_detail', slug=p.slug) }}" class="card">
    <img src="{{ p.cover_url }}" alt="">
    <h3>{{ p.nombre }}</h3>
    <p>Desde ${{ p.min_precio }}</p>
    <small>{{ p.supplier.razon_social }}</small>
  </a>
  {% endfor %}
</div>


Detalle – templates/market/product_detail.html

<h1>{{ product.nombre }}</h1>
<img src="{{ product.cover_url }}" alt="">
<form action="{{ url_for('cart.add_to_cart') }}" method="post">
  {{ csrf_token() }}
  <select name="variant_id">
    {% for v in variants if v.visible %}
      <option value="{{ v.id }}">{{ v.atributos_json.presentacion or v.unidad }} — ${{ v.precio }}</option>
    {% endfor %}
  </select>
  <input name="qty" type="number" value="1" min="1" step="1">
  <button type="submit">Agregar al carrito</button>
</form>


Carrito – templates/cart/view.html

<h1>Tu carrito</h1>
<table>
  <tr><th>Producto</th><th>Proveedor</th><th>Precio</th><th>Cant</th><th>Subtotal</th></tr>
  {% for it in items %}
  <tr>
    <td>{{ it.variant.product.nombre }}</td>
    <td>{{ it.variant.product.supplier.razon_social }}</td>
    <td>${{ it.precio_snapshot }}</td>
    <td>{{ it.qty }}</td>
    <td>${{ it.precio_snapshot * it.qty }}</td>
  </tr>
  {% endfor %}
</table>
<form action="{{ url_for('cart.checkout_confirm') }}" method="post">
  {{ csrf_token() }}
  <button type="submit">Confirmar compra</button>
</form>

Seed idempotente (demo)
# seed_suppliers.py
from decimal import Decimal
from app import db, create_app
from models import Supplier, SupplierUser, Category, Product, ProductVariant, ProductImage
from werkzeug.security import generate_password_hash
from slugify import slugify

app = create_app()

def get_or_create(model, defaults=None, **kwargs):
    inst = model.query.filter_by(**kwargs).first()
    if inst: return inst, False
    inst = model(**{**(defaults or {}), **kwargs}); db.session.add(inst); return inst, True

with app.app_context():
    sup,_ = get_or_create(Supplier, email="ventas@demo.com",
        defaults=dict(razon_social="Proveedor Demo", cuit="30-70999999-7", verificado=True))
    get_or_create(SupplierUser, email="owner@demo.com",
        defaults=dict(supplier_id=sup.id, nombre="Owner", password_hash=generate_password_hash("demo123")))
    cat,_ = get_or_create(Category, nombre="Materiales")

    nombre = "Cemento Portland 50kg"
    slug = slugify(nombre)
    prod,_ = get_or_create(Product, supplier_id=sup.id, nombre=nombre,
        defaults=dict(category_id=cat.id, slug=slug, descripcion="Bolsa 50kg", estado="publicado"))
    get_or_create(ProductVariant, product_id=prod.id, sku="CEM-50KG",
        defaults=dict(atributos_json={"presentacion":"50kg"}, unidad="u",
                      precio=Decimal("8500.00"), moneda="ARS", stock=Decimal("100.00"), visible=True))
    get_or_create(ProductImage, product_id=prod.id, url="/static/demo/cemento.jpg")
    db.session.commit(); print("Seed OK")

Validaciones y seguridad

CSRF en todos los POST.

Ownership: para rutas de proveedor verificar session['supplier_id'] coincide con el recurso.

Publicación: validar reglas antes de publicar.

Stock: re-validar en checkout; si falta stock, bloquear ese ítem.

Uploads: jpg/jpeg/png/webp, máx 10 MB, hasta 6 imágenes por producto, carpeta por proveedor.

Slugs: únicos (generar desde nombre + fallback con -id).

Auditoría: registrar cambios de precio/stock/publicación.

Búsqueda y performance

Consultas precargando Supplier, ProductImage (cover) y min(precio) de variantes.

Filtros por categoría/ubicación/precio con paginación.

(Opcional) Postgres full-text para product.nombre/descripcion.

Variables de entorno
PLATFORM_COMMISSION_RATE=0.02
IVA_RATE=0.21

STORAGE_BACKEND=local          # o s3
S3_ENDPOINT=
S3_BUCKET=obyra
S3_ACCESS_KEY=
S3_SECRET_KEY=

# Mercado Pago
MP_ACCESS_TOKEN=
MP_WEBHOOK_URL=https://tuservidor/webhooks/mp
MP_WEBHOOK_SECRET=opcional

# App
SECRET_KEY=supersecreto

Tareas (orden sugerido)

Migraciones Alembic de todos los modelos y nuevos campos.

Auth proveedor (/proveedor/registro, /proveedor/login).

CRUD Productos/Variantes/Imágenes con validaciones + publicar/pausar.

Marketplace público: /market/productos, /p/<slug>.

Carrito y Checkout (agrupación por proveedor).

Pago

A: MP split (/market/orden/<id>/checkout, /webhooks/mp).

B: flujo offline (subir factura + marcar pago).

Comisión 2%: OrderCommission + PDF + vistas en portal proveedor y admin.

Q&A y (si aplica) RFQ conviviendo con compra directa.

Seed y README con setup, env vars y colección Postman (rutas clave).

Criterios de Aceptación (DoD)

Portal proveedor operativo: registro/login/perfil + gestión de catálogo (productos, variantes, imágenes) + publicar/pausar.

Marketplace por producto con precio visible; detalle con variantes; carrito/checkout funcionando.

Órdenes por proveedor; pagos A: MP split activos; B: offline completo.

Comisión 2% calculada por orden; Factura de Comisión (PDF) generada/visible.

Seguridad (CSRF, ownership), validaciones (stock/precio/publicación) y paginación.

Seed idempotente y README con instrucciones exactas.

(Opcional) n8n listo para integrar

Webhook MP → marcar pagado → generar PDF comisión → emails.

RFQ fan-out a proveedores.
(Tenemos JSONs de flujos listos para importar cuando los pidan).

Con esto pueden implementarlo sin inventar nada y dejar el Marketplace tipo Mercado Libre funcionando con tu modelo de comisión del 2%.

ChatGPT puede cometer errores. Considera